ar
X
iv
:1
70
9.
01
05
6v
1 
 [
cs
.I
T
] 
 4
 S
ep
 2
01
7
Fundamental Limits of Cache-Aided Private Information
Retrieval with Unknown and Uncoded Prefetching?
Yi-Peng Wei Karim Banawan Sennur Ulukus
Department of Electrical and Computer Engineering
University of Maryland, College Park, MD 20742
ypwei@umd.edu kbanawan@umd.edu ulukus@umd.edu
September 5, 2017
Abstract
We consider the problem of private information retrieval (PIR) fromN non-colluding
and replicated databases when the user is equipped with a cache that holds an uncoded
fraction r from each of the K stored messages in the databases. We assume that the
databases are unaware of the cache content. We investigate D?(r) the optimal down-
load cost normalized with the message size as a function of K, N , r. For a fixed K,
N , we develop an inner bound (converse bound) for the D?(r) curve. The inner bound
is a piece-wise linear function in r that consists of K line segments. For the achiev-
ability, we develop explicit schemes that exploit the cached bits as side information to
achieve K ? 1 non-degenerate corner points. These corner points differ in the number
of cached bits that are used to generate one side information equation. We obtain an
outer bound (achievability) for any caching ratio by memory-sharing between these
corner points. Thus, the outer bound is also a piece-wise linear function in r that
consists of K line segments. The inner and the outer bounds match in general for the
cases of very low caching ratio (r ? 1
1+N+N2+···+NK?1
) and very high caching ratio
(r ? K?2
(N+1)K+N2?2N?2
). As a corollary, we fully characterize the optimal download
cost caching ratio tradeoff for K = 3. For general K, N , and r, we show that the
largest gap between the achievability and the converse bounds is 16 . Our results show
that the download cost can be reduced beyond memory-sharing if the databases are
unaware of the cached content.
1 Introduction
The problem of private information retrieval (PIR) was introduced by Chor et al. [1] as
a canonical problem to investigate the privacy of the contents downloaded from public
?This work was supported by NSF Grants CNS 13-14733, CCF 14-22111, and CNS 15-26608.
1
databases. The PIR problem has become a major research area within the computer science
literature subsequently, see e.g., [2–5]. In the classical form of the problem [1], a user requests
to download a message (or a file) from K messages from N non-communicating databases
such that no database can distinguish individually which message has been retrieved. The
user performs this task by preparing N queries, one for each database, such that the queries
do not reveal the user’s interest in the desired message. Each database responds truthfully
to the received query by an answer string. The user reconstructs the desired message from
the collected answer strings. A feasible PIR scheme is to download all of the K messages
from a database. However, this trivial PIR scheme is quite inefficient from the retrieval
rate perspective, which is defined as the number of desired bits per bit of downloaded data.
Consequently, the aim of the PIR problem is to retrieve the desired message correctly by
downloading as few bits as possible from the N databases under the privacy constraint.
Recently, the PIR problem is revisited by information theorists [6–9]. In the information-
theoretic re-formulation of the problem, the length of the message L is assumed to be ar-
bitrary large to conform with the traditional Shannon-theoretic arguments, and the upload
cost is neglected as it does not scale with the message length. This formulation provides an
absolute privacy guarantee by ensuring statistical independence between the queries and the
identity of the desired message. In the influential paper by Sun and Jafar [9], the notion of
PIR capacity is introduced, which is the supremum of PIR rates over all achievable retrieval
schemes. Reference [9] characterizes the capacity of classical PIR. In [9], a greedy iterative al-
gorithm is proposed for the achievability scheme and an induction based converse is provided
to obtain an exact result. The achievable scheme is based on an interesting correspondence
between PIR and blind interference alignment [10] as observed earlier in [11]. Sun and Jafar
show that in order to privately retrieve a message, the optimal total downloaded bits nor-
malized with the message size is D
L
= 1 + 1
N
+ · · ·+ 1
NK?1
. Consequently, the PIR capacity
is the reciprocal of this optimal normalized download cost, i.e., C = (1+ 1
N
+ · · ·+ 1
NK?1
)?1.
Following the work of [9], the fundamental limits of many interesting variants of the
classical PIR problem have been considered, such as: PIR with T colluding databases (TPIR)
[12, 13], where any T of N databases might collude; robust PIR (RPIR) [12], where some
databases may fail to respond; symmetric PIR (SPIR) [14], which adds the constraint that
the user should only learn the desired message; MDS-coded PIR (CPIR) [15], where the
contents of the databases are not replicated, but coded via an MDS code; multi-message
PIR (MPIR) [16], where the user wishes to jointly retrieve P messages; PIR from Byzantine
databases (BPIR), where B databases are outdated or worse adversarial [17]; PIR under
message size constraint L (LPIR) [18]; multi-round PIR, where the queries are permitted to
be a function of the answer strings collected in previous rounds [19]; MDS-coded symmetric
PIR [20]; MDS-coded PIR with colluding databases [21–23], and its multi-message [24], and
symmetric [25] versions.
Recently, reference [26] has considered cache-aided PIR, where the user has local cache
2
memory of size rKL bits and it can store any function of the K messages subject to this
memory size constraint1,2. With the assumption that the cache content is known by all
the N databases, reference [26] characterizes the optimal download cost. The achievability
scheme is based on memory-sharing and the converse bound is obtained with the aid of Han’s
inequality. To privately retrieve a message, the optimal total downloaded bits normalized
with the message size is D(r)
L
= (1? r)(1+ 1
N
+ · · ·+ 1
NK?1
). The result is quite pessimistic as
it implies that the cached bits cannot be used as side information within the retrieval scheme
and the user must download the uncached portion of the file (the remaining L(1 ? r) bits)
using the original PIR scheme in [9]. The reason behind this result is that the databases are
fully knowledgeable about the cached bits and can infer which message is desired if the user
exploits these cached bits as side information in any form.
The above discussion motivates us to investigate the other extreme where the databases
are fully unaware of the cache content, i.e., when the prefetched bits are unknown to all of
the N databases (in contrast to having the cache content as public knowledge at all the N
databases as in [26]). In this case, the user can leverage the cached bits as side information
without sacrificing the privacy constraint as the databases are unaware of the cached bits.
This poses an interesting question: What is the optimal way to exploit the cached bits as
side information in order to minimize the normalized download cost, and what is the cor-
responding gain beyond memory-sharing if any? The assumption of unknown prefetching
can be interpreted in practice as either the prefetching phase is performed via an external
database which does not participate in the retrieval (delivery) phase, or in the context of dy-
namic cache-aided PIR, in which once the unknown cache is used, the user updates/refreshes
its cached contents by some trusted mechanism which keeps the cached content essentially
random from the perspective of each database as pointed out by [26]. In this paper, we fur-
ther assume that the cache content is uncoded. As a main advantage, uncoded prefetching
allows us to handle asynchronous demands without increasing the communication rates, by
dividing files into smaller subfiles [30].
In this work, we consider PIR with unknown and uncoded prefetching, i.e., we assume
that the cache content is unknown to all databases, and the cache supports only direct
(uncoded) portions of all messages (smaller subfiles). We aim to characterize the optimal
tradeoff between the normalized download cost D(r)
L
and the caching ratio r. For the outer
bound, we explicitly determine the achievable download rates for specific K + 1 caching
ratios. Download rates for any other caching ratio can be achieved by proper memory-
sharing between the nearest two explicit points. This implies that the outer bound is a
piece-wise linear curve which consists of K line segments. For the inner bound, we extend
1Caching is an important technique to reduce the peak-time traffic in networks by pre-storing (prefetching)
content to end-user’s local memory [27, 28], and has been an active recent research field on its own right.
2In another related line of work, reference [29] investigates the privacy risks when the clients of an index
coding based broadcast system possess a subset of the messages as side information and use them to retrieve
the desired message privately against an external eavesdropper.
3
the techniques of [9, 26] to obtain a piece-wise linear curve which also consists of K line
segments. We show that the inner and the outer bounds match exactly at three of the
line segments for any number of messages K. This means that we characterize the optimal
tradeoff for the very low (r ? 1
1+N+N2+···+NK?1
) and the very high (r ? K?2
(N+1)K+N2?2N?2
)
caching ratios. As a direct corollary, we fully characterize the optimal download cost caching
ratio tradeoff for K = 3 messages. For general K, N and r, we show that for fixed N , the
outer bound monotonically increases as K increases. To characterize the worst-case gap
between the inner and the outer bounds, we determine the asymptotic achievability bound
as K ? ? for fixed N , r. We then show that the asymptotic gap monotonically decreases
in N . Therefore, the worst-case gap happens at N = 2 and K ? ?. By maximizing this
over r, we show that the largest gap between the achievability and the converse bounds is
1
6
. Our results show the benefits of the cached content when the databases are unaware of
it over the scenario in [26] where the databases are fully aware of the cached content.
2 System Model
We consider a classic PIR problem with K independent messagesW1, . . . ,WK . Each message
is of L bits long,
H(W1) = · · · = H(WK) = L, H(W1, . . . ,WK) = H(W1) + · · ·+H(WK). (1)
There are N non-communicating databases, and each database stores all the K messages,
i.e., the messages are coded via (N, 1) repetition code [15]. The user (retriever) has a local
cache memory whose content is denoted by a random variable Z. For each message Wk of L
bits long, the user randomly and independently caches Lr bits out of the L bits to Z, where
0 ? r ? 1, and r is called the caching ratio. Therefore,
H(Z) = KLr. (2)
Since the user caches a subset of the bits from each message, this is called uncoded prefetching.
We denote the indices of the cached bits by random variable H. Here, different from [26],
we consider the case where none of the databases knows the prefetched cache content.
After the uncoded prefetching phase, the user privately generates an index ? ? [K], where
[K] = {1, . . . , K}, and wishes to retrieve message W? such that no database knows which
message is retrieved. Note that during the prefetching phase, the desired message is unknown
a priori. Note further that the cached bit indices H are independent of the message contents
and the desired message index ?. Therefore, for random variables ?, H, and W1, . . . ,WK , we
have
H (?,H,W1, . . . ,WK) = H (?) +H (H) +H(W1) + · · ·+H(WK). (3)
4
Suppose ? = k. The user sends N queries Q
[k]
1 , . . . , Q
[k]
N to the N databases, where Q
[k]
n
is the query sent to the nth database for message Wk. The queries are generated according
to H, which is independent of the realizations of the K messages. Therefore, we have
I(W1, . . . ,WK ;Q
[k]
1 , . . . , Q
[k]
N ) = 0. (4)
To ensure that individual databases do not know which message is retrieved, we need to
satisfy the following privacy constraint, ?n ? [N ], ?k ? [K],
(Q[1]n , A
[1]
n ,W1, . . . ,WK) ? (Q
[k]
n , A
[k]
n ,W1, . . . ,WK). (5)
Upon receiving the query Q
[k]
n , the nth database replies with an answering string A
[k]
n ,
which is a function of Q
[k]
n and all the K messages. Therefore, ?k ? [K], ?n ? [N ],
H(A[k]n |Q
[k]
n ,W1, . . . ,WK) = 0. (6)
After receiving the answering strings A
[k]
1 , . . . , A
[k]
N from all the N databases, the user needs
to decode the desired message Wk reliably. By using Fano’s inequality, we have the following
reliability constraint
H
(
Wk|Z,H, Q
[k]
1 , . . . , Q
[k]
N , A
[k]
1 , . . . , A
[k]
N
)
= o(L), (7)
where o(L) denotes a function such that o(L)
L
? 0 as L? ?.
For a fixed N , K, and caching ratio r, a pair (D(r), L) is achievable if there exists a PIR
scheme for message of size L bits long with unknown and uncoded prefetching satisfying the
privacy constraint (5) and the reliability constraint (7), where D(r) represents the expected
number of downloaded bits (over all the queries) from the N databases via the answering
strings A
[k]
1:N , i.e.,
D(r) =
N
?
n=1
H
(
A[k]n
)
. (8)
In this work, we aim to characterize the optimal normalized download cost D?(r) corre-
sponding to every caching ratio 0 ? r ? 1, where
D?(r) = inf
{
D(r)
L
: (D(r), L) is achievable
}
, (9)
which is a function of the caching ratio r.
5
3 Main Results and Discussions
Our first result characterizes an outer bound (achievable rate) for the normalized download
cost D?(r) for general K, N , r.
Theorem 1 (Outer bound) In the cache-aided PIR with uncoded and unknown prefetch-
ing, let s ? {1, 2, · · · , K ? 1}, for the caching ratio rs, where
rs =
(
K?2
s?1
)
(
K?2
s?1
)
+
?K?1?s
i=0
(
K?1
s+i
)
(N ? 1)iN
, (10)
the optimal normalized download cost D?(rs) is upper bounded by,
D?(rs) ? D?(rs) =
?K?1?s
i=0
(
K
s+1+i
)
(N ? 1)iN
(
K?2
s?1
)
+
?K?1?s
i=0
(
K?1
s+i
)
(N ? 1)iN
(11)
Moreover, if rs < r < rs+1, and ? ? (0, 1) such that r = ?rs + (1? ?)rs+1, then
D?(r) ? D?(r) = ?D?(rs) + (1? ?)D?(rs+1) (12)
The proof of Theorem 1 can be found in Section 4. Theorem 1 implies that there exist
K + 1 interesting caching ratios denoted by rs, where s ? {1, 2, · · · , K ? 1} in addition
to r = 0 point (no caching) and r = 1 point (everything cached). The index s, which
characterizes rs for these points, represents the number of cached bits that can be used
within one bit of the download (if this downloaded bit uses cached bits as side information).
For example, if s = 2, this means that the user should use two of the cached bits as side
information in the form of mixture of two bits if the caching ratio is r2. The achievability
scheme for any other caching ratio r can be obtained by memory-sharing between the most
adjacent interesting caching ratios that include r. Consequently, the outer bound is a piece-
wise linear convex curve that connects the K + 1 interesting caching ratio points including
the (0, 1
C
) point, where C is the PIR capacity without caching found in [9], and (1, 0) where
everything is cached.
As a direct corollary for Theorem 1, we note that since the databases do not know the
cached bits, the download cost is strictly smaller than the case when the databases have
the full knowledge about the cached bits in [26]. We state and prove this in the following
corollary. As a concrete example, Figure 1 shows the gain that can be achieved due to the
unawareness of the databases about the cached bits.
Corollary 1 (Unawareness gain) The achievable normalized download cost D?(r) in the
cache-aided PIR with known prefetching [26]
D?(r) = (1? r)
(
1 +
1
N
+ · · ·+
1
NK?1
)
(13)
6
0 0.2 0.4 0.6 0.8 1
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
r
D L
 
 
Unknown prefetching
Known prefetching
Figure 1: Comparison between the optimal download cost for known prefetching (13) in [26]
and the achievable download cost for unknown prefetching in (11) for K = 5, N = 2.
is strictly larger than the achievable normalized download cost D?(r) in (11), i.e., the databases’
unawareness contributes to reducing the download cost beyond the memory-sharing scheme
in [26].
Proof: For r = 0, the achievable download cost D?(r) in (11) is
(
1 + 1
N
+ · · ·+ 1
NK?1
)
, which
is the same as (13). For r = 1, the achievable download cost D?(r) in (11) is 0, which is
the same as (13). To show that D?(r) in (13) is always larger than D?(r) in (11), it suffices
to show that there exists a caching ratio r such that D?(r) < D?(r), since the other caching
ratios can be achieved by the memory-sharing scheme. Taking s = K ? 1 in (10), we have
rK?1 =
1
1+N
. For r = 1
1+N
, we have D?(r) = N
1+N
, and D?(r) = N
1+N
(
1 + 1
N
+ · · ·+ 1
NK?1
)
.
Therefore, for rK?1, we have D?(r) < D?(r), which shows the sub-optimality of D?(r) in (13)
for the case of known prefetching. 
Our second result characterizes an inner bound (converse bound) for the normalized
download cost D?(r) for general K, N , r.
Theorem 2 (Inner bound) In the cache-aided PIR with uncoded and unknown prefetch-
ing, the normalized download cost is lower bounded as,
D?(r) ? D?(r) = max
i?{2,··· ,K+1}
(1? r)
K+1?i
?
j=0
1
N j
? r
K?i
?
j=0
K + 1? i? j
N j
, (14)
7
The proof of Theorem 2 can be found in Section 5. Theorem 2 implies that the inner
bound is also a piece-wise linear curve, which consists of K line segments with decreasing
slope as r increases. The points at which the curve changes its slope are given by,
r?i =
1
1 +N +N2 + · · ·+NK?i
, i = 1, · · · , K ? 1. (15)
We note that ri in (10) and r?i in (15) are the same for i = 1 and i = K ? 1.
As a consequence of Theorem 1 and Theorem 2, we characterize the optimal download
cost caching ratio tradeoff for very low and very high caching ratios in the following corollary.
Here, by very low caching ratios we mean 0 ? r ? r1 = r?1 =
1
1+N+N2+···+NK?1
, and by very
high caching ratios we mean rK?2 =
K?2
(N+1)K+N2?2N?2
? r ? 1. Note that, in the very high
caching ratios, we have two segments, one in rK?2 ? r ? rK?1 and the other in rK?1 ? r ? 1.
Therefore, in the inner and outer bounds, each composed of K line segments, the first (very
low r) and the last two (very high r) segments match giving exact result. This is stated and
proved in the next corollary.
Corollary 2 (Optimal tradeoff for very low and very high caching ratios) In the
cache-aided PIR with uncoded and unknown prefetching, for very low caching ratios, i.e., for
r ? 1
1+N+N2+···+NK?1
, the optimal normalized download cost is given by,
D?(r) = (1? r)
(
1 +
1
N
+ · · ·+
1
NK?1
)
? r
(
(K ? 1) +
K ? 2
N
+ · · ·+
1
NK?2
)
(16)
On the other hand, for very high caching ratios, i.e., for r ? K?2
(N+1)K+N2?2N?2
, the optimal
normalized download cost is given by,
D?(r) =
{
(1? r)
(
1 + 1
N
)
? r, K?2
(N+1)K+N2?2N?2
? r ? 1
1+N
1? r, 1
1+N
? r ? 1
(17)
Proof: First, from (10) and (15), let us note that
r1 = r?1 =
1
1 +N +N2 + · · ·+NK?1
, (18)
rK?2 =
K ? 2
(N + 1)K +N2 ? 2N ? 2
, (19)
rK?1 = r?K?1 =
1
1 +N
. (20)
Then, we note from (11) that
D?(r1) =
?K?2
i=0
(
K
2+i
)
(N ? 1)iN
(
K?2
0
)
+
?K?2
i=0
(
K?1
1+i
)
(N ? 1)iN
(21)
8
=
N
(N?1)2
[
NK ?
?1
i=0
(
K
i
)
(N ? 1)i
]
(
K?2
0
)
+ N
(N?1)1
[
NK?1 ?
?0
i=0
(
K?1
i
)
(N ? 1)i
] (22)
=
N
[
NK ? 1?K(N ? 1)
]
(N ? 1)2 +N(N ? 1) [NK?1 ? 1]
(23)
=
NK+1 ?KN2 + (K ? 1)N
NK+1 ?NK ?N + 1
(24)
Further, we note from (14), by choosing i = 2 and using r = r1, that
D?(r1) ? (1? r1)
K+1?2
?
j=0
1
N j
? r1
K?2
?
j=0
K ? 1? j
N j
(25)
=
(
1?
N ? 1
NK ? 1
)
NK ? 1
NK ?NK?1
?
N ? 1
NK ? 1
N
1?N
(
?K +
NK ? 1
NK ?NK?1
)
(26)
=
NK ?N
NK ? 1
NK ? 1
NK ?NK?1
+
N
NK ? 1
(
?K +
NK ? 1
NK ?NK?1
)
(27)
=
NK ?N
NK ?NK?1
+N
(
?K
NK ? 1
+
1
NK ?NK?1
)
(28)
=
NK+1 ?KN2 + (K ? 1)N
NK+1 ?NK ?N + 1
(29)
= D?(r1) (30)
Thus, since D?(r1) ? D?(r1) by definition, (30) implies D?(r1) = D?(r1).
Similarly, from (11),
D?(rK?2) =
?1
i=0
(
K
K?1+i
)
(N ? 1)iN
(
K?2
K?3
)
+
?1
i=0
(
K?1
K?2+i
)
(N ? 1)iN
(31)
=
N2 + (K ? 1)N
N2 + (K ? 2)N + (K ? 2)
, (32)
and from (14) by choosing i = K and using r = rK?2,
D?(rK?2) ? (1? rK?2)
1
?
j=0
1
N j
? rK?2
0
?
j=0
1? j
N j
(33)
=
(
N2 + (K ? 2)N
N2 + (K ? 2)N + (K ? 2)
)(
1 +
1
N
)
?
K ? 2
N2 + (K ? 2)N + (K ? 2)
(34)
=
N2 + (K ? 1)N
N2 + (K ? 2)N + (K ? 2)
(35)
= D?(rK?2) (36)
implying D?(rK?2) = D?(rK?2).
9
0 0.2 0.4 0.6 0.8 1
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
r
D L
 
 
Achievability
Converse
(1,0)
(0,15/8)
(1/15,22/15)
(1/7,8/7) (1/5,1)
(1/3,2/3)
Figure 2: Inner and outer bounds for K = 4, N = 2.
Finally, from (11),
D?(rK?1) =
N
1 +N
, (37)
and from (14) by choosing i = K + 1 and using r = rK?1,
D?(rK?1) ?
N
1 +N
= D?(rK?1) (38)
implying D?(rK?1) = D?(rK?1).
Therefore, D?(r) = D?(r) at r = r1, r = rK?2 and r = rK?1. We also note that D?(0) =
D?(0) and D?(1) = D?(1). Since both D?(r) and D?(r) are linear functions of r, and since
D?(0) = D?(0) and D?(r1) = D?(r1), we have D?(r) = D?(r) = D
?(r) for 0 ? r ? r1. This is the
very low caching ratio region. In addition, since D?(rK?2) = D?(rK?2), D?(rK?1) = D?(rK?1)
and D?(1) = D?(1), we have D?(r) = D?(r) = D?(r) for rK?2 ? r ? 1. This is the very high
caching ratio region. 
As an example, the case of K = 4, N = 2 is shown in Figure 2. In this case, r1 = r?1 =
1
15
,
rK?2 =
1
5
, and rK?1 = r?K?1 =
1
3
. Therefore, we have exact results for 0 ? r ? 1
15
(very
low caching ratios) and 1
5
? r ? 1 (very high caching ratios). We have a gap between the
achievability and the converse for medium caching ratios in 1
15
? r ? 1
5
. More specifically,
line segments connecting (0, 15
8
) and ( 1
15
, 22
15
); connecting (1
5
, 1) and (1
3
, 2
3
); and connecting
(1
3
, 2
3
) and (1, 0) are tight.
10
0 0.2 0.4 0.6 0.8 1
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
r
D L
 
 
N = 2
N = 4
N = 8
N = 16
(0,7/4)
(1/7,8/7)
(1/3, 2/3)
(1,0)
Figure 3: Optimal download cost caching ratio tradeoff for the case of K = 3 messages.
Finally, we characterize the exact tradeoff curve for any N , r for the special case of K = 3
in the following corollary.
Corollary 3 (Optimal tradeoff for K = 3) In the cache-aided PIR with uncoded and un-
known prefetching with K = 3 messages, the optimal download cost caching ratio tradeoff is
given explicitly as (see Figure 3),
D?(r) =
?
?
?
?
?
(1? r)
(
1 + 1
N
+ 1
N2
)
? r
(
2 + 1
N
)
, 0 ? r ? 1
1+N+N2
(1? r)
(
1 + 1
N
)
? r, 1
1+N+N2
? r ? 1
1+N
1? r, 1
1+N
? r ? 1
(39)
Proof: The proof follows from the proof of Corollary 2. Note that in this case, from (18)
and (19), r1 = rK?2 =
1
1+N+N2
; and from (20), r2 = rK?1 =
1
1+N
. Thus, we have a
tight result for 0 ? r ? r1 =
1
1+N+N2
(very low caching ratios) and a tight result for
rK?2 = r1 =
1
1+N+N2
? r ? 1, i.e., a tight result for all 0 ? r ? 1. We have three segments
in this case: [0, r1], [r1, r2] and [r2, 1] with three different line expressions for the exact result
as given in (10)-(11) and written explicitly in (39). 
4 Achievability Proof
Our achievability scheme is based on the PIR schemes in [9,26]. Similar to [9], we apply the
following three principles recursively: 1) database symmetry, 2) message symmetry within
11
each database, and 3) exploiting undesired messages as side information. Different from [9],
we start the PIR scheme from the third principle due to the availability of pre-existing side
information as a result of uncoded prefetching. These cached bits can be exploited right
away as side information without compromising the privacy constraint as the databases do
not know them. We begin the discussion by presenting the case of K = 3, N = 2 as a
motivating example to illustrate the main ideas of our achievability scheme.
4.1 Motivating Example: The Optimal Tradeoff Curve for K = 3
Messages, N = 2 Databases
In this example, we show the achievability for K = 3, N = 2. We know from Corollary 3
that the inner and the outer bounds match for this case. The optimal download cost caching
ratio tradeoff is shown in Figure 3. We note that there are 4 corner points. Two fo them are
degenerate, corresponding to r = 0, r = 1 caching ratios. For r = 0, the user has no cached
bits and is forced to apply the achievable scheme in [9] that achieves D?(0) = 7
4
= 1
C
. For
r = 1, the user has already cached the entire desired file and does not download any extra
bits from the databases, i.e., D?(1) = 0. We have two other corner points, corresponding
to r1 =
1
1+N+N2
= K?2
(N+1)K+N2?2N?2
= 1
7
, and r2 =
1
1+N
= 1
3
. In the sequel, we show the
achievability of these two corner points.
4.1.1 Caching Ratio r1 =
1
7
Let s be the number of cached bits that are mixed together to form side information equation.
The first corner point corresponds to s = 1. This means that the user exploits every bit in
the cache individually as a side information. Using the notation in [16], we can say that the
user starts downloading from round 2 that sums bits from very two messages together. We
next show how s = 1 suffices to achieve r1 =
1
7
, D?(1
7
) = 8
7
for K = 3, N = 2; see Figure 3.
We use ai, bi, and ci to denote the bits of messages W1, W2 and W3, respectively. We
assume that the user wants to retrieve message W1 privately without loss of generality.
We initialize the process by permuting the indices of messages W1,W2,W3 randomly and
independently. The steps of the retrieval can be followed in Table 1. The user has already
cached one bit from each message, i.e., a1, b1, c1 as denoted by Z in Table 1. We start from
the third principle by exploiting each bit in the cache as an individual side information. The
user downloads a2 + b1 and a3 + c1 from the first database (DB1). Then, we apply the first
principle, and the user downloads a4 + b1 and a5 + c1 from the second database (DB2) to
satisfy the database symmetry. Next, we apply the second principle to ensure the message
symmetry within the queries. The user downloads b2 + c2 from DB1, and b3 + c3 from DB2.
At this point, all side information corresponding to the cached bits have been exploited.
Next, we apply the third principle, since undesired message mixes are available in the form
of b2 + c2 and b3 + c3. The user downloads a6 + b3 + c3 from DB1. Finally, we apply the
12
first principle of database symmetry, and the user downloads a7 + b2 + c2 from DB2. Now,
the iterations stop, since all the undesired side information is used and the symmetry across
databases and symmetry within the queries is attained. We summarize the process in the
query table in Table 1.
Table 1: Query table for K = 3, N = 2, r1 =
1
7
s DB1 DB2
s
=
1 a2 + b1 a4 + b1
a3 + c1 a5 + c1
b2 + c2 b3 + c3
a6 + b3 + c3 a7 + b2 + c2
Z = (a1, b1, c1)
Since the databases do not know the local cache memory Z, and for each database, the
user’s queries are symmetric across messages, the privacy constraint (5) is satisfied. The
decodability can be easily checked as the user can cancel out b1, c1 which it has previously
cached, and also cancel b2 + c2 and b3 + c3 which are previously downloaded, to obtain
a2, · · · , a7. Since a1 is already cached, the user has a1, · · · , a7. Here, L = 7 and the user
has cached 1 bit from each message. There are total of 8 downloads. Hence r = 1
7
, and
D?(1
7
) = 8
7
.
4.1.2 Caching Ratio r2 =
1
3
For the second non-degenerate corner point, we have s = 2. This means that each 2 bits
from the cache are mixed together to form a side information equation. We next show how
s = 2 suffices to achieve r2 =
1
3
, D?(1
3
) = 2
3
for K = 3, N = 2; see Figure 3.
Let [a1, a2, a3], [b1, b2, b3], and [c1, c2, c3] denote a random permutation of the 3 bits of
messages W1, W2 and W3, respectively. Suppose the user caches a1, b1, c1 in advance and
wants to retrieve message W1 privately. We start from the third principle. The user down-
loads a2 + b1 + c1 from the first database (DB1). Then, we apply the first principle, and the
user downloads a3+ b1+ c1 from the second database (DB2). Now, the iterations stop, since
all the undesired side information is used and the symmetry across databases and messages
is attained. We summarize the process in the query table in Table 2. In this case L = 3,
hence r = 1
3
, and the normalized download cost is D?(1
3
) = 2
3
.
Table 2: Query table for K = 3, N = 2, r2 =
1
3
s DB1 DB2
s = 2 a2 + b1 + c1 a3 + b1 + c1
Z = (a1, b1, c1)
13
4.1.3 Caching Ratio r = 1
5
So far, we have characterized all the corner points by varying s = 1, 2 and achieved the
points corresponding to caching ratios rs in addition to the degenerate caching ratios r = 0
and r = 1; see Figure 3. An achievable scheme for any other caching ratio can be obtained
by memory-sharing between the two nearest corner points. As an example, we next consider
the caching ratio r = 1
5
.
The achievability scheme for this case is a combination of the achievability schemes in
Sections 4.1.1 and 4.1.2. Observe that by choosing L = 10, the achievable schemes in
Sections 4.1.1 and 4.1.2 can be concatenated to achieve the caching ratio r = 1
5
. In this case,
the user caches a1, a2, b1, b2, c1, c2 and wants to retrieve message W1 privately. For cached
bits a1, b1, c1, we apply the same process as in Section 4.1.1, i.e., we use s = 1 and use every
cached bit as individual side information equation. For cached bits a2, b2, c2, we apply the
same process as in Section 4.1.2, and choose s = 2, which implies that we use the mixture
of two cached bits as a side information equation. We summarize the process in the query
table in Table 3.
Table 3: Query table for K = 3, N = 2, r = 1
5
s DB1 DB2
s = 1
a3 + b1 a5 + b1
a4 + c1 a6 + c1
b3 + c3 b4 + c4
a7 + b4 + c4 a8 + b3 + c3
s = 2 a9 + b2 + c2 a10 + b2 + c2
Z = (a1, a2, b1, b2, c1, c2)
Here, we have L = 10, therefore r = 1
5
, and D?(1
5
) = 10
10
= 1. In fact, by applying [26,
Lemma 1] and taking ? = 7
10
, we can show that the normalized download cost of this
example can be obtained from the download costs obtained in Sections 4.1.1 and 4.1.2, as
D?(1
5
) = D?(1
7
· 7
10
+ 1
3
· 3
10
) = 7
10
D?(1
7
) + 3
10
D?(1
3
) = 7
10
· 8
7
+ 3
10
· 2
3
= 1.
4.2 Achievable Scheme for the Corner Points for Arbitrary K, N
For fixed N and K, there are K? 2 non-degenerate corner points (in addition to degenerate
caching ratios r = 0, r = 1). The caching ratios corresponding to these non-degenerate
corner points are indexed by s, which enumerate the number of cached bits that are involved
in the side information mixture. Hence, rs is given by
rs =
(
K?2
s?1
)
(
K?2
s?1
)
+
?K?1?s
i=0
(
K?1
s+i
)
(N ? 1)iN
, (40)
14
where s ? {1, 2, . . . , K ? 1}. We choose the length of the message to be L(s) for the corner
point indexed by s, where
L(s) =
(
K ? 2
s? 1
)
+
K?1?s
?
i=0
(
K ? 1
s+ i
)
(N ? 1)iN (41)
bits per message. The details of the achievable scheme are as follows:
1. Initialization: The user permutes each message randomly and independently. The user
caches randomly and privately
(
K?2
s?1
)
bits from each message. Set the round index to
i = s + 1, where the ith round involves downloading sums of every i combinations of
the K messages.
2. Exploiting side information: If i = s + 1, the user mixes s bits from the cache bits to
form one side information equation. Each side information equation is added to one bit
from the uncached portion of the desired message. Therefore, the user downloads
(
K?1
s
)
equations in the form of a desired bit added to a mixture of s cached bits from other
messages. On the other hand, if i > s+1, the user exploits the
(
K?1
i?1
)
(N ?1)i?s?1 side
information equations generated from the remaining (N ?1) databases in the (i?1)th
round.
3. Symmetry across databases: The user downloads the same number of equations with
the same structure as in step 2 from every database. Consequently, the user downloads
(
K?1
i?1
)
(N ? 1)i?s?1 bits from every database, which are done either using the cached
bits as side information if i = s+ 1, or the side information generated in the (i? 1)th
round if i > s+ 1.
4. Message symmetry: To satisfy the privacy constraint, the user should download equal
amount of bits from all other messages. Therefore, the user downloads
(
K?1
i
)
(N ?
1)i?s?1 undesired equations from each database in the form of sum of i bits from the
uncached portion of the undesired messages.
5. Repeat steps 2, 3, 4 after setting i = i+ 1 until i = K.
6. Shuffling the order of queries: By shuffling the order of queries uniformly, all possible
queries can be made equally likely regardless of the message index. This guarantees
the privacy.
4.2.1 Decodability, Privacy, and the Achievable Normalized Download Cost
Decodability: It is clear that the side information in each round is either constructed
from the cached bits (if i = s+ 1) or obtained from the remaining (N ? 1) databases in the
(i ? 1)th round. Consequently, the user can cancel out these side information bits in order
to decode the uncached portion of the desired message (the remaining L(1? r) bits).
15
Privacy: The randomized mapping of the cached and the uncached portions of the mes-
sages and the randomization of the order of queries guarantees privacy as in [9].
Normalized Download Cost: We now calculate the total number of downloaded bits
for the caching ratio r in (40). First, we exploit s bits of side information. Therefore,
each download is a sum of s + 1 bits. Since the second principle enforces symmetry across
K messages, we download
(
K
s+1
)
bits from a database. Due to the first principle enforcing
symmetry across databases, in total, we download
(
K
s+1
)
N bits. Since we utilize s bits of
side information of undesired messages for each download, for each undesired message we
use
(K?1
s
)s
K?1
=
(
K?2
s?1
)
bits, which is the amount of bits we cached in advance for each message.
Next, each download is a sum of s+2 bits since the available side information is in the form
of sums of s+1 bits. Due to message symmetry and (N ?1) available side information from
other (N?1) databases, we download
(
K
s+2
)
(N?1) bits from each database. Due to the first
principle enforcing symmetry across databases, in total, we download
(
K
s+2
)
(N ? 1)N bits.
Next, each download is sum of s+3 bits since the available side information is in the form of
sums of s+ 2 bits. Note that in the previous iteration, each database provides (N ? 1) sets
of side information, and each database exploits the side information from the other (N ? 1)
databases. Therefore, we download
(
K
s+3
)
(N ? 1)2 bits from each database. Due to the first
principle enforcing symmetry across databases, in total, we download
(
K
s+3
)
(N ? 1)2N bits.
By continuing in this manner, the total number of downloaded bits is,
D(rs) =
K?1?s
?
i=0
(
K
s+ 1 + i
)
(N ? 1)iN. (42)
Now, we calculate the number of desired bits we have downloaded in this process. At the
beginning of the iteration, each download is a sum of s+ 1 bits. If the download includes a
desired bit, the other s bits are from the local cache memory. Therefore, we download
(
K?1
s
)
desired bits from each database, and thus we download a total of
(
K?1
s
)
N desired bits. Next,
each download is sum of s+2 bits. If the download includes a desired bit, the other s+1 bits
are from the side information of undesired bits. For each database, there are (N ? 1) sets
of side information obtained from the previous iteration with one set from each database.
Therefore, we download
(
K?1
s+1
)
(N?1) bits from each database, and thus we download a total
of
(
K?1
s+1
)
(N ? 1)N desired bits. Next, each download is sum of s + 3 bits. If the download
includes a desired bit, the other s + 2 bits are from the side information of undesired bits.
For each database, there are (N ? 1)2 sets of side information obtained from the previous
iteration with (N ? 1) sets from one database. Therefore, we download
(
K?1
s+2
)
(N ? 1)2N
desired bits, and thus the number of desired bits we downloaded is L(s)?
(
K?2
s?1
)
, where L(s)
16
is given in (41). Finally, the normalized download cost is,
D?(rs) =
D(rs)
L(s)
=
?K?1?s
i=0
(
K
s+1+i
)
(N ? 1)iN
(
K?2
s?1
)
+
?K?1?s
i=0
(
K?1
s
)
(N ? 1)iN
. (43)
4.3 Achievable Scheme for Non-Corner Points for Arbitrary K, N
For caching ratios r which are not exactly equal to (40) for some s, we first find an s such
that rs < r < rs+1, and combine the achievability schemes of rs and rs+1. Then, we can
write the achievable normalized download cost as a convex combination of D?(rs) and D?(rs+1)
using [26, Lemma 1] as follows,
D?(r) = ?D?(rs) + (1? ?)D?(rs+1), (44)
where r = ?rs + (1? ?)rs+1 and rs is defined in (40), and D?(r) is given in (43).
5 Converse Proof
In this section, we derive an inner bound for the cache-aided PIR with uncoded and unknown
prefetching. The inner bound is tight in general for very high and very low caching ratios,
and in particular, the inner bound is tight everywhere for K = 3. We extend the techniques
presented in [9, 26] to our problem. We first need the following lemma, which characterizes
a lower bound on the length of the undesired portion of the answer strings as a consequence
of the privacy constraint.
Lemma 1 (Interference lower bound) For the cache-aided PIR with unknown and un-
coded prefetching, the interference from undesired messages within the answer strings D(r)?
L(1? r) is lower bounded by,
D(r)? L(1? r) + o(L) ? I
(
Wk:K ;H, Q
[k?1]
1:N , A
[k?1]
1:N |W1:k?1, Z
)
(45)
for all k ? {2, . . . , K}.
If the privacy constraint is absent, the user downloads only L(1?r) bits in order to decode
the desired message, however, when the privacy constraint is present, it should download
D(r). The difference D(r) ? L(1 ? r) corresponds to the undesired portion of the answer
strings. Lemma 1 shows that this portion is lower bounded by the mutual information
between the answer strings and the messages Wk:K after knowing the first W1:k?1 messages
and the cached bits. Lemma 1 provides K? 1 lower bounds on D(r)?L(1? r) by changing
the index k from 2 to K. Each of these K?1 bounds contributes a different line segment for
the final inner bound. Note that Lemma 1 is an extension to [9, Lemma 5] if k = 2, r = 0.
17
Proof: We start with the right hand side of (45),
I
(
Wk:K ;H, Q
[k?1]
1:N , A
[k?1]
1:N |W1:k?1, Z
)
= I
(
Wk:K;H, Q
[k?1]
1:N , A
[k?1]
1:N ,Wk?1|W1:k?2, Z
)
? I (Wk:K;Wk?1|W1:k?2, Z) (46)
For the first term on the right hand side of (46), we have
I
(
Wk:K ;H, Q
[k?1]
1:N , A
[k?1]
1:N ,Wk?1|W1:k?2, Z
)
= I
(
Wk:K;H, Q
[k?1]
1:N , A
[k?1]
1:N |W1:k?2, Z
)
+ I
(
Wk:K;Wk?1|H, Q
[k?1]
1:N , A
[k?1]
1:N ,W1:k?2, Z
)
(47)
(7)
= I
(
Wk:K;H, Q
[k?1]
1:N , A
[k?1]
1:N |W1:k?2, Z
)
+ o(L) (48)
(3),(4)
= I
(
Wk:K;A
[k?1]
1:N |W1:k?2, Z,H, Q
[k?1]
1:N
)
+ o(L) (49)
= H
(
A
[k?1]
1:N |W1:k?2, Z,H, Q
[k?1]
1:N
)
?H
(
A
[k?1]
1:N |W1:k?2, Z,H, Q
[k?1]
1:N ,Wk:K
)
+ o(L) (50)
(7)
= H
(
A
[k?1]
1:N |W1:k?2, Z,H, Q
[k?1]
1:N
)
?H
(
Wk?1, A
[k?1]
1:N |W1:k?2, Z,H, Q
[k?1]
1:N ,Wk:K
)
+ o(L) (51)
? H
(
A
[k?1]
1:N |W1:k?2, Z,H, Q
[k?1]
1:N
)
?H
(
Wk?1|W1:k?2, Z,H, Q
[k?1]
1:N ,Wk:K
)
+ o(L) (52)
(3),(4)
= H
(
A
[k?1]
1:N |W1:k?2, Z,H, Q
[k?1]
1:N
)
?H (Wk?1|Z) + o(L) (53)
= H
(
A
[k?1]
1:N |W1:k?2, Z,H, Q
[k?1]
1:N
)
? L(1? r) + o(L) (54)
? D(r)? L(1? r) + o(L) (55)
where (48), (51) follow from the reliability constraint ofWk?1, (49) follows from the indepen-
dence between the queries Q
[k?1]
1:N and the messagesWk:K , (52) follows from the non-negativity
of the entropy function, (53) is due to the fact that Wk?1 is statistically independent of
(W1:k?2,Wk:K,H, Q
[k?1]
1:N ), (54) follows from the uncoded nature of the cache, and (55) fol-
lows from conditioning reduces entropy.
For the second term on the right hand side of (46), we have
I (Wk:K ;Wk?1|W1:k?2, Z) = H (Wk?1|W1:k?2, Z)?H (Wk?1|W1:k?2,Wk:K, Z) (56)
= (L? Lr)? (L? Lr) (57)
= 0 (58)
Combining (46), (55), and (58) yields (45). 
In the following lemma, we prove an inductive relation for the mutual information term
on the right hand side of (45).
18
Lemma 2 (Induction lemma) For all k ? {2, . . . , K}, the mutual information term in
Lemma 1 can be inductively lower bounded as,
I
(
Wk:K;H, Q
[k?1]
1:N , A
[k?1]
1:N |W1:k?1, Z
)
?
1
N
I
(
Wk+1:K ;H, Q
[k]
1:N , A
[k]
1:N |W1:k, Z
)
+
L(1 ? r)? o(L)
N
? (K ? k + 1)Lr. (59)
Lemma 2 relates the mutual information between Wk:K and the answer strings to the
same mutual information term withWk+1:K, i.e., it shifts the term by one message. Since the
two terms have the same structure, Lemma 2 constructs an inductive relation. We obtain
an explicit lower bound for I
(
Wk:K ;H, Q
[k?1]
1:N , A
[k?1]
1:N |W1:k?1, Z
)
by applying this lemma
K ? k+1 times, and therefore characterize an explicit lower bound on D(r)?L(1? r). We
do this in Lemma 3 by combining Lemma 1 and Lemma 2. Lemma 2 reduces to [9, Lemma 6]
if r = 0.
Proof: We start with the left hand side of (59),
I
(
Wk:K;H, Q
[k?1]
1:N , A
[k?1]
1:N |W1:k?1, Z
)
= I
(
Wk:K ;H, Q
[k?1]
1:N , A
[k?1]
1:N , Z|W1:k?1
)
? I(Wk:K ;Z|W1:k?1) (60)
= I
(
Wk:K ;Q
[k?1]
1:N , A
[k?1]
1:N |W1:k?1
)
+ I
(
Wk:K;H, Z|W1:k?1, Q
[k?1]
1:N , A
[k?1]
1:N
)
? I(Wk:K ;Z|W1:k?1) (61)
? I
(
Wk:K;Q
[k?1]
1:N , A
[k?1]
1:N |W1:k?1
)
? I(Wk:K;Z|W1:k?1) (62)
where (62) follows from the non-negativity of mutual information.
For the first term in (62), we have
NI
(
Wk:K ;Q
[k?1]
1:N , A
[k?1]
1:N |W1:k?1
)
?
N
?
n=1
I
(
Wk:K;Q
[k?1]
n , A
[k?1]
n |W1:k?1
)
(63)
(5)
=
N
?
n=1
I
(
Wk:K ;Q
[k]
n , A
[k]
n |W1:k?1
)
(64)
(3)
=
N
?
n=1
I
(
Wk:K ;A
[k]
n |W1:k?1, Q
[k]
n
)
(65)
(6)
=
N
?
n=1
H
(
A[k]n |W1:k?1, Q
[k]
n
)
(66)
?
N
?
n=1
H
(
A[k]n |W1:k?1,H, Q
[k]
1:N , A
[k]
1:n?1, Z
)
(67)
19
(6)
=
N
?
n=1
I
(
Wk:K ;A
[k]
n |W1:k?1,H, Q
[k]
1:N , A
[k]
1:n?1, Z
)
(68)
= I
(
Wk:K ;A
[k]
1:N |W1:k?1,H, Q
[k]
1:N , Z
)
(69)
(3)
= I
(
Wk:K;H, Q
[k]
1:N , A
[k]
1:N |W1:k?1, Z
)
(70)
(7)
= I
(
Wk:K;Wk,H, Q
[k]
1:N , A
[k]
1:N |W1:k?1, Z
)
? o(L) (71)
= I
(
Wk:K ;H, Q
[k]
1:N , A
[k]
1:N |W1:k, Z
)
+ I (Wk:K ;Wk|W1:k?1, Z)? o(L) (72)
= I
(
Wk:K ;H, Q
[k]
1:N , A
[k]
1:N |W1:k, Z
)
+ L(1? r)? o(L) (73)
= I
(
Wk+1:K ;H, Q
[k]
1:N , A
[k]
1:N |W1:k, Z
)
+ L(1? r)? o(L) (74)
where (63), (67) follow from the non-negativity of mutual information,(65), follows from the
independence of Wk:K, and Q
[k]
n , (64) follows from the privacy constraint, (66), (68) follow
from the fact that the answer string A
[k]
n is a deterministic function of (Q
[k]
n ,W1:K), (69)
follows from the chain rule, (70) follows from the statistical independence of (H, Q
[k]
1:N ,Wk:K),
(71) is consequence of the decodability of Wk from (Q
[k]
1:N , A
[k]
1:N), and (73) is due to the
uncoded assumption of the cached bits.
For the second term in (62), we have
I(Wk:K ;Z|W1:k?1) = H (Z|W1:k?1)?H(Z|W1:K) (75)
= (K ? k + 1)Lr (76)
where (76) follows from the uncoded nature of the cached bits.
Combining (62), (74), and (76) yields (59). 
Now we are ready to derive the general inner bound for arbitrary K, N , r. To obtain
this bound, we use Lemma 1 to find K lower bounds on the length of the undesired portion
of the answer strings D(r)? L(1 ? r). Each lower bound is obtained by varying the index
k in the lemma from k = 2 to k = K. Next, we inductively lower bound each result of
Lemma 1 by using Lemma 2, precisely (K ? k + 1) times, to get K explicit lower bounds.
This is stated in the following lemma.
Lemma 3 For N and K, we have
D(r) ? L(1? r)
K+1?k
?
j=0
1
N j
? Lr
K?k
?
j=0
K + 1? k ? j
N j
? o(L), (77)
where k = 2, . . . , K + 1.
20
Proof: We have
D(r) + o(L)
(45)
? L(1 ? r) + I
(
Wk:K;H, Q
[k?1]
1:N , A
[k?1]
1:N |W1:k?1, Z
)
(78)
(59)
? L(1 ? r) +
L(1? r)? o(L)
N
? (K ? k + 1)Lr
+
1
N
I
(
Wk+1:K ;H, Q
[k]
1:N , A
[k]
1:N |W1:k, Z
)
(79)
(59)
? L(1 ? r)
[
1 +
1
N
+
1
N2
+ o(L)
]
? Lr
[
(K ? k + 1) +
(K ? k)
N
]
+
1
N2
I
(
Wk+2:K;H, Q
[k+1]
1:N , A
[k+1]
1:N |W1:k+1, Z
)
(59)
? . . . (80)
(59)
? L(1 ? r)
K+1?k
?
j=0
1
N j
? Lr
K?k
?
j=0
K + 1? k ? j
N j
+ o(L), (81)
where (78) follows from Lemma 1 starting from general index k, and the remaining bounding
steps correspond to successive application of Lemma 2. 
We conclude the converse proof by dividing by L and taking the limit as L ? ?, then
for k = 2, · · · , K + 1, we have
D?(r) ? (1? r)
K+1?k
?
j=0
1
N j
? r
K?k
?
j=0
K + 1? k ? j
N j
(82)
Finally, (82) gives K intersecting line segments, therefore, the normalized download cost
is lower bounded by their maximum value
D?(r) ? max
i?{2,··· ,K+1}
(1? r)
K+1?i
?
j=0
1
N j
? r
K?i
?
j=0
K + 1? k ? j
N j
(83)
6 Further Examples
6.1 K = 4 Messages, N = 2 Databases
For K = 4 and N = 2, we show the achievable PIR schemes for caching ratios r1 =
1
15
in
Table 4, r2 =
1
5
in Table 5, and r3 =
1
3
in Table 6. The achievable normalized download costs
for these caching ratios are 22
15
, 1 and 2
3
, respectively. We show the normalized download cost
and caching ratio trade off curve in Figure 2.
21
Table 4: Query table for K = 4, N = 2 and r1 =
1
15
s DB1 DB2
s
=
1
a2 + b1 a5 + b1
a3 + c1 a6 + c1
a4 + d1 a7 + d1
b2 + c2 b4 + c4
b3 + d2 b5 + d4
c3 + d3 c5 + d5
a8 + b4 + c4 a11 + b2 + c2
a9 + b5 + d4 a12 + b3 + d2
a10 + c5 + d5 a13 + c3 + d3
b6 + c6 + d6 b7 + c7 + d7
a14 + b7 + c7 + d7 a15 + b6 + c6 + d6
Z = (a1, b1, c1, d1)
Table 5: Query table for K = 4, N = 2, r2 =
1
5
s DB1 DB2
s
=
2
a3 + b1 + c1 a6 + b1 + c1
a4 + d1 + b2 a7 + d1 + b2
a5 + c2 + d2 a8 + c2 + d2
b3 + c3 + d3 b4 + c4 + d4
a9 + b4 + c4 + d4 a10 + b3 + c3 + d3
Z = (a1, a2, b1, b2, c1, c2, d1, d2)
Table 6: Query table for K = 4, N = 2, r3 =
1
3
s DB1 DB2
s = 3 a2 + b1 + c1 + d1 a3 + b1 + c1 + d1
Z = (a1, b1, c1, d1)
6.2 K = 4 Messages, N = 3 Databases
For K = 4 and N = 3, we show the achievable PIR schemes for caching ratios r1 =
1
40
in
Table 7, r2 =
2
17
in Table 8, and r3 =
1
4
in Table 9. We show the normalized download
cost and caching ratio trade off in Figure 4. The achievable normalized download costs for
22
these caching ratios are 27
20
, 18
17
and 3
4
, respectively. By comparing Figure 4 with Figure 2,
we observe that, for fixed K, as N grows, the gap between the achievable bound and the
converse bound shrinks. This observation will be specified in Section 7.
Table 7: Query table for K = 4, N = 3, r1 =
1
40
s DB1 DB2 DB3
s
=
1
a2 + b1 a5 + b1 a8 + b1
a3 + c1 a6 + c1 a9 + c1
a4 + d1 a7 + d1 a10 + d1
b2 + c2 b4 + c4 b6 + c6
b3 + d2 b5 + d4 b7 + d6
c3 + d3 c5 + d5 c7 + d7
a11 + b4 + d4 a17 + b2 + c2 a23 + b2 + c2
a12 + b5 + d4 a18 + b3 + d2 a24 + b3 + d2
a13 + c5 + d5 a19 + c3 + d3 a25 + c3 + d3
a14 + b6 + c6 a20 + b6 + c6 a26 + b4 + c4
a15 + b7 + d6 a21 + b7 + d6 a27 + b5 + d4
a16 + c7 + d7 a22 + c7 + d7 a28 + c5 + d5
b8 + c8 + d8 b10 + c10 + d10 b12 + c12 + d12
b9 + c9 + d9 b11 + c11 + d11 b13 + c13 + d13
a29 + b10 + c10 + d10 a33 + b8 + c8 + d8 a37 + b8 + c8 + d8
a30 + b11 + c11 + d11 a34 + b9 + c9 + d9 a38 + b9 + c9 + d9
a31 + b12 + c12 + d12 a35 + b12 + c12 + d12 a39 + b10 + c10 + d10
a32 + b13 + c13 + d13 a36 + b13 + c13 + d13 a40 + b11 + c11 + d11
Z = (a1, b1, c1, d1)
Table 8: Query table for K = 4, N = 3, r2 =
2
17
s DB1 DB2 DB3
s
=
2
a3 + b1 + c1 a6 + b1 + c1 a9 + b1 + c1
a4 + d1 + b2 a7 + d1 + b2 a10 + d1 + b2
a5 + c2 + d2 a8 + c2 + d2 a11 + c2 + d2
b3 + c3 + d3 b4 + c4 + d4 b5 + c5 + d5
a12 + b4 + c4 + d4 a14 + b3 + c3 + d3 a16 + b3 + c3 + d3
a13 + b5 + c5 + d5 a15 + b5 + c5 + d5 a17 + b4 + c4 + d4
Z = (a1, a2, b1, b2, c1, c2, d1, d2)
23
0 0.2 0.4 0.6 0.8 1
0
0.5
1
1.5
r
D L
 
 
Achievability
Converse
(1/13, 15/13)
(1/40, 27/20)
(0, 40/27)
(1,0)
(1/4, 3/4)
(2/17, 18/17)
Figure 4: Inner and outer bounds for K = 4, N = 3.
Table 9: Query table for K = 4, N = 3, r3 =
1
4
s DB1 DB2 DB3
s = 3 a2 + b1 + c1 + d1 a3 + b1 + c1 + d1 a4 + b1 + c1 + d1
Z = (a1, b1, c1, d1)
6.3 K = 5, K = 10 and K = 100 Messages, N = 2 Databases
For N = 2, we show the numerical results for the inner and outer bounds for K = 5, K = 10
and K = 100 in Figures 5, 6 and 7. For fixed N as K grows, the gap between the achievable
bound and converse bound increases. This observation will be specified in Section 7.
6.4 K = 5, K = 10 and K = 100 Messages, N = 3 Databases
For N = 3, we show the numerical results for the inner and outer bounds for K = 5, K = 10
and K = 100 in Figures 8, 9 and 10. For fixed N as K grows, the gap between the achievable
bound and converse bound increases. This observation will be specified in Section 7.
24
0 0.2 0.4 0.6 0.8 1
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
r
D L
 
 
Achievability
Converse
Figure 5: Inner and outer bounds for K = 5, N = 2.
7 Gap Analysis
In this section, we analyze the gap between the achievability and converse bounds for general
N , K, and r, and show that the worst-case gap, which happens when N = 2 and K ? ?,
is at most 1
6
. We start this section with an interesting property for the monotonicity of the
achievable bounds. We first see an example. For N = 2, K = 4, K = 5 and K = 6, the
achievable bounds are shown in Figure 11. The achievable bound for K = 6 is above the
achievable bound for K = 5, and the achievable bound for K = 5 is above the achievable
bound forK = 4. By denoting r
(K)
s as the caching ratio with totalK messages and parameter
s (see (10)), we observe that (r
(5)
1 , D?(r
(5)
1 )) falls on the line connecting (r
(4)
0 , D?(r
(4)
0 )) and
(r
(4)
1 , D?(r
(4)
1 )). This observation is general, (r
(K+1)
s , D?(r
(K+1)
s )) falls on the line connecting
(r
(K)
s?1, D?(r
(K)
s?1)) and (r
(K)
s , D?(r
(K)
s )). We state and prove this observation in the following
lemma.
Lemma 4 (Monotonicity of the achievable bounds) In cache-aided PIR with uncoded
and unknown prefetching, for fixed number of databases N , if the number of messages K
increases, then the achievable normalized download cost increases. Furthermore, we have
r(K+1)s = ?r
(K)
s?1 + (1? ?)r
(K)
s , (84)
D?(r(K+1)s ) = ?D?(r
(K)
s?1) + (1? ?)D?(r
(K)
s ), (85)
25
0 0.2 0.4 0.6 0.8 1
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
r
D L
 
 
Achievability
Converse
Figure 6: Inner and outer bounds for K = 10, N = 2.
where 0 ? ? ? 1.
Proof: To show (85) is equivalent to show
D?(r(K+1)s )? D?(r
(K)
s ) = ?
(
D?(r
(K)
s?1)? D?(r
(K)
s )
)
. (86)
From (84), we have
? =
r
(K)
s ? r
(K+1)
s
r
(K)
s ? r
(K)
s?1
. (87)
Therefore, to show (86) is equivalent to show
(
r(K)s ? r
(K)
s?1
)
(
D?(r(K+1)s )? D?(r
(K)
s )
)
=
(
r(K)s ? r
(K+1)
s
)
(
D?(r
(K)
s?1)? D?(r
(K)
s )
)
. (88)
Let D?(r
(K)
s ) =
D
(K)
s
L
(K)
s
, where
L(K)s =
(
K ? 2
s? 1
)
+
K?1?s
?
i=0
(
K ? 1
s+ i
)
(N ? 1)iN, (89)
D(K)s =
K?1?s
?
i=0
(
K
s+ 1 + i
)
(N ? 1)iN. (90)
26
0 0.2 0.4 0.6 0.8 1
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
r
D L
 
 
Achievability
Converse
Figure 7: Inner and outer bounds for K = 100, N = 2.
To show (88) is equivalent to show
[
(
K?2
s?1
)
L
(K)
s
?
(
K?2
s?2
)
L
(K)
s?1
][
D
(K+1)
s
L
(K+1)
s
?
D
(K)
s
L
(K)
s
]
=
[
(
K?2
s?1
)
L
(K)
s
?
(
K?1
s?1
)
L
(K+1)
s
][
D
(K)
s?1
L
(K)
s?1
?
D
(K)
s
L
(K)
s
]
, (91)
which is obtained by using (10), (11), (89) and (90). Expanding (91), we have
(
K?2
s?1
)
L
(K)
s
D
(K+1)
s
L
(K+1)
s
?
(
K?2
s?2
)
L
(K)
s?1
D
(K+1)
s
L
(K+1)
s
+
(
K?2
s?2
)
L
(K)
s?1
D
(K)
s
L
(K)
s
=
(
K?2
s?1
)
L
(K)
s
D
(K)
s?1
L
(K)
s?1
?
(
K?1
s?1
)
L
(K+1)
s
D
(K)
s?1
L
(K)
s?1
+
(
K?1
s?1
)
L
(K+1)
s
D
(K)
s
L
(K)
s
.
(92)
Multiplying L
(K)
s L
(K)
s?1L
(K+1)
s to both side of (92), we have
(
K ? 2
s? 1
)
D(K+1)s L
(K)
s?1 +
(
K ? 1
s? 1
)
D
(K)
s?1L
(K)
s +
(
K ? 2
s? 2
)
D(K)s L
(K+1)
s
=
(
K ? 2
s? 1
)
D
(K)
s?1L
(K+1)
s +
(
K ? 2
s? 2
)
D(K+1)s L
(K)
s +
(
K ? 1
s? 1
)
D(K)s L
(K)
s?1. (93)
By using (89) and (90), we further have
(
K ? 2
s? 1
)
[
K?s
?
i=0
(
K + 1
s+ 1 + i
)
(N ? 1)iN
][
(
K ? 2
s? 2
)
+
K?s
?
i=0
(
K ? 1
s? 1 + i
)
(N ? 1)iN
]
27
0 0.2 0.4 0.6 0.8 1
0
0.5
1
1.5
r
D L
 
 
Achievability
Converse
Figure 8: Inner and outer bounds for K = 5, N = 3.
+
(
K ? 1
s? 1
)
[
K?s
?
i=0
(
K
s+ i
)
(N ? 1)iN
] [
(
K ? 2
s? 1
)
+
K?1?s
?
i=0
(
K ? 1
s+ i
)
(N ? 1)iN
]
+
(
K ? 2
s? 2
)
[
K?1?s
?
i=0
(
K
s+ 1 + i
)
(N ? 1)iN
][
(
K ? 1
s? 1
)
+
K?s
?
i=0
(
K
s+ i
)
(N ? 1)iN
]
=
(
K ? 2
s? 1
)
[
K?s
?
i=0
(
K
s+ i
)
(N ? 1)iN
][
(
K ? 1
s? 1
)
+
K?s
?
i=0
(
K
s+ i
)
(N ? 1)iN
]
+
(
K ? 2
s? 2
)
[
K?s
?
i=0
(
K + 1
s+ 1 + i
)
(N ? 1)iN
] [
(
K ? 2
s? 1
)
+
K?1?s
?
i=0
(
K ? 1
s+ i
)
(N ? 1)iN
]
+
(
K ? 1
s? 1
)
[
K?1?s
?
i=0
(
K
s+ 1 + i
)
(N ? 1)iN
][
(
K ? 2
s? 2
)
+
K?s
?
i=0
(
K ? 1
s? 1 + i
)
(N ? 1)iN
]
.
(94)
By canceling same terms on both sides, we have
(
K ? 2
s? 1
)
[
K?s
?
i=0
(
K + 1
s+ 1 + i
)
(N ? 1)i
][
K?s
?
i=0
(
K ? 1
s? 1 + i
)
(N ? 1)i
]
+
(
K ? 1
s? 1
)
[
K?s
?
i=0
(
K
s+ i
)
(N ? 1)i
][
K?1?s
?
i=0
(
K ? 1
s+ i
)
(N ? 1)i
]
28
0 0.2 0.4 0.6 0.8 1
0
0.5
1
1.5
r
D L
 
 
Achievability
Converse
Figure 9: Inner and outer bounds for K = 10, N = 3.
+
(
K ? 2
s? 2
)
[
K?1?s
?
i=0
(
K
s+ 1 + i
)
(N ? 1)i
][
K?s
?
i=0
(
K
s+ i
)
(N ? 1)i
]
=
(
K ? 2
s? 1
)
[
K?s
?
i=0
(
K
s + i
)
(N ? 1)i
][
K?s
?
i=0
(
K
s+ i
)
(N ? 1)i
]
+
(
K ? 2
s? 2
)
[
K?s
?
i=0
(
K + 1
s+ 1 + i
)
(N ? 1)i
][
K?1?s
?
i=0
(
K ? 1
s+ i
)
(N ? 1)i
]
+
(
K ? 1
s? 1
)
[
K?1?s
?
i=0
(
K
s+ 1 + i
)
(N ? 1)i
][
K?s
?
i=0
(
K ? 1
s? 1 + i
)
(N ? 1)i
]
. (95)
By using the fact that
(
K
s
)
=
(
K?1
s
)
+
(
K?1
s?1
)
, we have
(
K ? 2
s? 1
)
[
K?s
?
i=0
((
K
s + 1 + i
)
+
(
K
s+ i
))
(N ? 1)i
][
K?s
?
i=0
(
K ? 1
s? 1 + i
)
(N ? 1)i
]
+
((
K ? 2
s? 1
)
+
(
K ? 2
s? 2
))
[
K?s
?
i=0
(
K
s+ i
)
(N ? 1)i
][
K?1?s
?
i=0
(
K ? 1
s+ i
)
(N ? 1)i
]
+
(
K ? 2
s? 2
)
[
K?1?s
?
i=0
(
K
s+ 1 + i
)
(N ? 1)i
][
K?s
?
i=0
((
K ? 1
s+ i
)
+
(
K ? 1
s+ i? 1
))
(N ? 1)i
]
29
0 0.2 0.4 0.6 0.8 1
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
r
D L
 
 
Achievability
Converse
Figure 10: Inner and outer bounds for K = 100, N = 3.
=
(
K ? 2
s? 1
)
[
K?s
?
i=0
(
K
s+ i
)
(N ? 1)i
][
K?s
?
i=0
((
K ? 1
s+ i
)
+
(
K ? 1
s+ i? 1
))
(N ? 1)i
]
+
(
K ? 2
s? 2
)
[
K?s
?
i=0
((
K
s+ 1 + i
)
+
(
K
s+ i
))
(N ? 1)i
][
K?1?s
?
i=0
(
K ? 1
s+ i
)
(N ? 1)i
]
+
((
K ? 2
s? 1
)
+
(
K ? 2
s? 2
))
[
K?1?s
?
i=0
(
K
s+ 1 + i
)
(N ? 1)i
][
K?s
?
i=0
(
K ? 1
s? 1 + i
)
(N ? 1)i
]
.
(96)
Since the left hand side of (96) is equal to the right hand side of (96), (85) holds.
To show ? ? 0, since r
(K)
s > r
(K)
s?1 in (87), it suffices to show that r
(K)
s ? r
(K+1)
s . From
(10), it is equivalent to show that
(
K?2
s?1
)
(
K?2
s?1
)
+
?K?1?s
i=0
(
K?1
s+i
)
(N ? 1)iN
?
(
K?1
s?1
)
(
K?1
s?1
)
+
?K?s
i=0
(
K
s+i
)
(N ? 1)iN
. (97)
By using the fact that
(
K
s
)
=
(
K?1
s
)
+
(
K?1
s?1
)
, we have
(
K?2
s?1
)
(
K?2
s?1
)
+
?K?1?s
i=0
(
K?1
s+i
)
(N ? 1)iN
?
(
K?2
s?1
)
+
(
K?2
s?2
)
(
K?2
s?1
)
+
(
K?2
s?2
)
+
?K?s
i=0
[(
K?1
s+i
)
+
(
K?1
s+i?1
)]
(N ? 1)iN
,
(98)
30
0 0.05 0.1 0.15 0.2 0.25 0.3 0.35
0.6
0.8
1
1.2
1.4
1.6
1.8
2
r
D L
 
 
K = 4
K = 5
K = 6
Figure 11: Outer bounds for N = 2, K = 4, K = 5 and K = 6.
which is equivalent to
(
K?2
s?1
)
(
K?2
s?1
)
+
?K?1?s
i=0
(
K?1
s+i
)
(N ? 1)iN
?
(
K?2
s?2
)
(
K?2
s?2
)
+
?K?s
i=0
(
K?1
s+i?1
)
(N ? 1)iN
. (99)
By using (10), (99) is equivalent to
r(K)s ? r
(K)
s?1. (100)
Since (100) holds, we have ? ? 0. Furthermore, ? ? 1 can be proved similarly. For
fixed N , since D?(r
(K+1)
0 ) > D?(r
(K)
0 ), the achievable normalized download cost monotonically
increases. 
The following lemma provides an asymptotic upper bound for the achievable normalized
download cost as a smooth function in (r,N). From this expression, we characterize the
worst-case gap between the outer and the inner bounds to be 1
6
.
Lemma 5 (Asymptotics and the worst-case gap) In cache-aided PIR with uncoded and
unknown prefetching, as K ? ?, the outer bound is tightly upper bounded by,
D?(r) ?
N(1? r)2
(N ? 1) + r
(101)
Hence, the worst-case gap is 1
6
. The asymptotic unawareness multiplicative gain over memory-
31
sharing in [26] is 1?r
1+ r
N?1
? 1.
Proof: We write the outer bound D?(rs) as
D?(rs) =
?K?1?s
i=0
(
K
s+1+i
)
(N ? 1)iN
(
K?2
s?1
)
+
?K?1?s
i=0
(
K?1
s+i
)
(N ? 1)iN
(102)
=
?
K?1?s
i=0 (
K
s+1+i)(N?1)
i
?
K?1?s
i=0 (
K?1
s+i )(N?1)i
(K?2
s?1 )
?
K?1?s
i=0 (
K?1
s+i )(N?1)iN
+ 1
(103)
=
?1(N,K, s)
?2(N,K, s) + 1
. (104)
Denote ? = s
K
. To upper bound ?1(N,K, s),
?1(N,K, s) =
?K?1?s
i=0
(
K
s+1+i
)
(N ? 1)i
?K?1?s
i=0
(
K?1
s+i
)
(N ? 1)i
(105)
=
?K?1?s
i=0
K
s+1+i
(
K?1
s+i
)
(N ? 1)i
?K?1?s
i=0
(
K?1
s+i
)
(N ? 1)i
(106)
?
?K?1?s
i=0
K
s
(
K?1
s+i
)
(N ? 1)i
?K?1?s
i=0
(
K?1
s+i
)
(N ? 1)i
=
1
?
. (107)
We upper bound the reciprocal of ?2(N,K, s) as,
1
?2(N,K, s)
= N
K?1?s
?
i=0
(
K?1
s+i
)
(N ? 1)i
(
K?2
s?1
) (108)
= N
K?1?s
?
i=0
(K ? 1)(K ? 1? s)(K ? 2? s) · · · (K ? i? s)
s(s+ 1)(s+ 2) · · · (s+ i)
(N ? 1)i (109)
? N
K?1?s
?
i=0
K(K ? s)i
si+1
(N ? 1)i (110)
= N
(1??)K?1
?
i=0
(1? ?)i
?i+1
(N ? 1)i (111)
=
N
?
(1??)K?1
?
i=0
(
(1? ?)(N ? 1)
?
)i
. (112)
Now, if ? > 1? 1
N
, then (1??)(N?1)
?
< 1. Hence, as K ? ?, 1
?2(N,K,s)
converges to
lim
K??
1
?2(N,K, s)
?
N
?
?
?
i=0
(
(1? ?)(N ? 1)
?
)i
(113)
32
=
N
?
·
1
1? (1??)(N?1)
?
(114)
=
N
N?? (N ? 1)
. (115)
Moreover, (109) can be lower bounded by keeping the first ?K terms in the sum for any
? such that 0 < ? < 1? ?,
1
?2(N,K, s)
? N
?K
?
i=0
(K ? 1)(K ? 1? s)(K ? 2? s) · · · (K ? i? s)
s(s+ 1)(s+ 2) · · · (s+ i)
(N ? 1)i (116)
? N
?K
?
i=0
(K ? 1)(K ? ?K ? s)i
(s+ ?K)i+1
(N ? 1)i (117)
= N
?K
?
i=0
(1? 1
K
)((1? (?+ ?))i
(?+ ?)i+1
(N ? 1)i. (118)
Similarly, by taking K ? ?, for any 0 < ? < 1? ?, we have
lim
K??
1
?2(N,K, s)
?
N
?+ ?
?
?
i=0
(
(1? (?+ ?))(N ? 1)
?+ ?
)i
(119)
=
N
N(?+ ?)? (N ? 1)
. (120)
Since ? is arbitrarily chosen, then as K ? ?, ?? 0, we have ?2(N,K, s) ?
N??(N?1)
N
.
Consequently, as K ? ?, rs converges to
rs ? r = lim
K??
(
K?2
s?1
)
(
K?2
s?1
)
+
?K?1?s
i=0
(
K?1
s+i
)
(N ? 1)iN
(121)
= lim
K??
?2(N,K, s)
?2(N,K, s) + 1
(122)
=
N?? (N ? 1)
N? + 1
. (123)
Note that if ? = 1 ? 1
N
, then r = 0, while if ? = 1, then r = 1
1+N
. This means that
the restriction in the limit to have ? > 1 ? 1
N
is without loss of generality as ? > 1 ? 1
N
corresponds to the entire range of r other than the 1 ? r matching bound. We can write ?
as
? =
r + (N ? 1)
N(1? r)
. (124)
33
Substituting in (104), we have the following upper bound on D?(r)
D?(r) ?
1
?
N??(N?1)
N
+ 1
(125)
=
N
?(N?+ 1)
(126)
=
N
r+(N?1)
N(1?r)
(
r+(N?1)
(1?r)
+ 1
) (127)
=
N2(1? r)2
(r + (N ? 1))2 + (1? r)(r + (N ? 1))
(128)
=
N2(1? r)2
Nr +N(N ? 1)
(129)
=
N(1 ? r)2
(N ? 1) + r
. (130)
The memory-sharing scheme in [26] achieves N
N?1
(1?r) if K ? ?, hence the asymptotic
unawareness gain is given by the multiplicative factor 1?r
1+ r
N?1
? 1.
For the inner bound, we note that the ith corner point is given by,
r?i =
1
1 +N + · · ·+N i
, i = 1, · · · , K ? 1. (131)
Therefore, although there exist K linear bounds, it suffices to consider only a small number
of them, as the remaining bounds are concentrated around r = 0. Denote the gap between
the inner and the outer bounds by ?(N,K, r). We note that the gap ?(N,?, r) is a piece-
wise convex function for 0 ? r ? 1 since it is the difference between a convex function D?(r)
and a piece-wise linear function. Hence, the maximizing caching ratio for the gap exists
exactly at the corner points r?i and it suffices to examine the gap at these corner points.
For the outer bound, we have
D?(r?i) ?
N
(
1? 1
1+N+···+N i
)2
(N ? 1) + 1
1+N+···+N i
(132)
=
N(1 +N +N2 + · · ·+N i ? 1)2
(N ? 1)(1 +N + · · ·+N i)2 + (1 +N + · · ·+N i)
(133)
=
N2(1 +N + · · ·+N i?1)2
N i(1 +N + · · ·+N i)
. (134)
Furthermore, for the inner bound, we have
D?(r?i) =
(
1 +
1
N
+ · · ·+
1
N i
)
?
1
1 +N + · · ·+N i
(
(i+ 1) +
i
N
+ · · ·+
1
N i
)
(135)
=
1 +N + · · ·+N i
N i
?
(i+ 1)N i + iN i?1 + · · ·+ 1
N i(1 +N + · · ·+N i)
(136)
34
=
(1 +N + · · ·+N i)2 ? (1 + 2N + 3N2 + · · ·+ (i+ 1)N i)
N i(1 +N + · · ·+N i)
(137)
Consequently, we can upper bound the asymptotic gap at the corner point r?i as
?(N,?, r?i)
= D?(r?i)? D?(r?i) (138)
?
N2(1 +N + · · ·+N i?1)2 ? (1 +N + · · ·+N i)2 + (1 + 2N + 3N2 + · · ·+ (i+ 1)N i)
N i(1 +N + · · ·+N i)
(139)
=
?(1 + 2N(1 +N + · · ·+N i?1)) + (1 + 2N + 3N2 + · · ·+ (i+ 1)N i)
N i(1 +N + · · ·+N i)
(140)
=
N2 + 2N3 + · · ·+ (i? 1)N i
N i(1 +N + · · ·+N i)
(141)
=
1
N i?2
+ 2
N i?3
+ · · ·+ (i? 1)
1 +N + · · ·+N i
(142)
Hence, ?(N,?, r?i) is monotonically decreasing in N . Therefore,
?(N,K, r) ? ?(2,?, r) ? max
i
(2)2 + 2(2)3 + · · ·+ (i? 1)(2)i
2i(1 + 2 + · · ·+ 2i)
(143)
For the case N = 2, we note that all the inner bounds after the 6th corner point are
concentrated around r = 0 since r?i ?
1
127
for i ? 6. Therefore, it suffices to characterize the
gap only for the first 6 corner points. Considering the 6th corner point which corresponds
to r?6 =
1
127
= 0.0078, and D?(r) ? 2 trivially for all r, and D?( 1
127
) = 1.8898. Hence,
?(2,?, r) ? 0.11, for r ? 1
127
. Now, we focus on calculating the gap at r?i, i = 1, · · · , 6.
Examining all the corner points, we see that r = 1
15
is the maximizing caching ratio for the
gap (corresponding to i = 3), and ?(2,?, 1
15
) ? 1
6
, which is the worst-case gap. 
8 Conclusion
In this paper, we studied the cache-aided PIR problem from N non-communicating and
replicated databases, when the cache stores uncoded bits that are unknown to the databases.
We determined inner and outer bounds for the optimal normalized download cost D?(r) as
a function of the total number of messages K, the number of databases N , and the caching
ratio r. Both inner and outer bounds are piece-wise linear functions in r (for fixed N , K) that
consist of K line segments. The bounds match in two specific regimes: the very low caching
ratio regime, i.e., r ? 1
1+N+N2+···+NK?1
, where D?(r) = (1 ? r)
(
1 + 1
N
+ · · ·+ 1
NK?1
)
?
r
(
(K ? 1) + K?2
N
+ · · ·+ 1
NK?2
)
; and the very high caching ratio regime, where D?(r) =
(1 ? r)(1 + 1
N
) ? r, for K?2
(N+1)K+N2?2N?2
? r ? 1
1+N
and D?(r) = 1 ? r, for r ? 1
1+N
. As a
35
direct corollary for this result, we characterized the exact tradeoff between the download cost
and the caching ratio for K = 3. For general K, N , and r, we showed that the largest gap
between the achievability and the converse bounds is 1
6
. The outer bound shows significant
reduction in the download cost with respect to the case when the cache content is fully known
at all databases [26], which achieves D?(r) = (1?r)(1+ 1
N
+ · · ·+ 1
NK?1
) by memory-sharing.
The achievable scheme extends the greedy scheme in [9] so that it starts with exploiting
the cache bits as side information. For fixed K, N , there are K ? 1 non-degenerate corner
points. These points differ in the number of cached bits that contribute in generating one
side information equation. The achievability for the remaining caching ratios is done by
memory-sharing between the two adjacent corner points that enclose that caching ratio r.
For the converse, we extend the induction-based techniques in [9, 26] to account for the
availability of uncoded and unknown prefetching at the retriever. The converse proof hinges
on developing K ? 1 lower bounds on the length of the undesired portion of the answer
string. By applying induction on each bound separately, we obtain the piece-wise linear
inner bound.
References
[1] B. Chor, E. Kushilevitz, O. Goldreich, and M. Sudan. Private information retrieval.
Journal of the ACM, 45(6):965–981, 1998.
[2] W. Gasarch. A survey on private information retrieval. In Bulletin of the EATCS, 2004.
[3] C. Cachin, S. Micali, and M. Stadler. Computationally private information retrieval
with polylogarithmic communication. In International Conference on the Theory and
Applications of Cryptographic Techniques. Springer, 1999.
[4] R. Ostrovsky and W. Skeith III. A survey of single-database private information re-
trieval: Techniques and applications. In International Workshop on Public Key Cryp-
tography, pages 393–411. Springer, 2007.
[5] S. Yekhanin. Private information retrieval. Communications of the ACM, 53(4):68–73,
2010.
[6] N. B. Shah, K. V. Rashmi, and K. Ramchandran. One extra bit of download ensures
perfectly private information retrieval. In IEEE ISIT, June 2014.
[7] R. Tajeddine and S. El Rouayheb. Private information retrieval from MDS coded data
in distributed storage systems. In IEEE ISIT, July 2016.
[8] T. Chan, S. Ho, and H. Yamamoto. Private information retrieval for coded storage. In
IEEE ISIT, June 2015.
36
[9] H. Sun and S. A. Jafar. The capacity of private information retrieval. IEEE Trans. on
Info. Theory, 63(7):4075–4088, July 2017.
[10] S. Jafar. Blind interference alignment. IEEE Journal of Selected Topics in Signal
Processing, 6(3):216–227, June 2012.
[11] H. Sun and S. Jafar. Blind interference alignment for private information retrieval. 2016.
Available at arXiv:1601.07885.
[12] H. Sun and S. Jafar. The capacity of robust private information retrieval with colluding
databases. 2016. Available at arXiv:1605.00635.
[13] R. Tajeddine, O. W. Gnilke, D. Karpuk, R. Freij-Hollanti, C. Hollanti, and S. El Rouay-
heb. Private information retrieval schemes for coded data with arbitrary collusion pat-
terns. 2017. Available at arXiv:1701.07636.
[14] H. Sun and S. Jafar. The capacity of symmetric private information retrieval. 2016.
Available at arXiv:1606.08828.
[15] K. Banawan and S. Ulukus. The capacity of private information retrieval from coded
databases. IEEE Trans. on Info. Theory. Submitted September 2016. Also available at
arXiv:1609.08138.
[16] K. Banawan and S. Ulukus. Multi-message private information retrieval: Capacity
results and near-optimal schemes. IEEE Trans. on Info. Theory. Submitted February
2017. Also available at arXiv:1702.01739.
[17] K. Banawan and S. Ulukus. The capacity of private information retrieval from Byzantine
and colluding databases. IEEE Trans. on Info. Theory. Submitted June 2017. Also
available at arXiv:1706.01442.
[18] H. Sun and S. Jafar. Optimal download cost of private information retrieval for arbitrary
message length. 2016. Available at arXiv:1610.03048.
[19] H. Sun and S. Jafar. Multiround private information retrieval: Capacity and storage
overhead. 2016. Available at arXiv:1611.02257.
[20] Q. Wang and M. Skoglund. Symmetric private information retrieval for MDS coded
distributed storage. 2016. Available at arXiv:1610.04530.
[21] R. Freij-Hollanti, O. Gnilke, C. Hollanti, and D. Karpuk. Private information retrieval
from coded databases with colluding servers. 2016. Available at arXiv:1611.02062.
[22] H. Sun and S. Jafar. Private information retrieval from MDS coded data with collud-
ing servers: Settling a conjecture by Freij-Hollanti et al. 2017. Available at arXiv:
1701.07807.
37
[23] Y. Zhang and G. Ge. A general private information retrieval scheme for MDS coded
databases with colluding servers. 2017. Available at arXiv: 1704.06785.
[24] Y. Zhang and G. Ge. Multi-file private information retrieval from MDS coded databases
with colluding servers. 2017. Available at arXiv: 1705.03186.
[25] Q. Wang and M. Skoglund. Linear symmetric private information retrieval for MDS
coded distributed storage with colluding servers. 2017. Available at arXiv:1708.05673.
[26] R. Tandon. The capacity of cache aided private information retrieval. 2017. Available
at arXiv: 1706.07035.
[27] M. A. Maddah-Ali and U. Niesen. Fundamental limits of caching. IEEE Trans. on Inf.
Theory, 60(5):2856–2867, May 2014.
[28] M. A. Maddah-Ali and U. Niesen. Decentralized coded caching attains order-optimal
memory-rate tradeoff. IEEE/ACM Trans. on Networking, 23(4):1029–1040, Aug. 2015.
[29] M. Karmoose, L. Song, M. Cardone, and C. Fragouli. Private broadcasting: an index
coding approach. 2017. Available at arXiv: 1701.04958.
[30] Q. Yu, M. A. Maddah-Ali, and A. S. Avestimehr. The exact rate-memory tradeoff for
caching with uncoded prefetching. Sep. 2016. Available at arXiv:1609.07817.
38
