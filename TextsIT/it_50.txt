1
Practical Inner Codes for Batched Sparse
Codes in Wireless Multi-hop Networks
Zhiheng Zhou, Member, IEEE, Congduan Li, Member, IEEE,
Shenghao Yang, Member, IEEE, and Xuan Guang, Member, IEEE
Abstract
Batched sparse (BATS) code is a promising technology for reliable data transmission in multi-hop
wireless networks. As a BATS code consists of an outer code and an inner code that typically is a random
linear network code, one main research topic for BATS codes is to design an inner code with good
performance in transmission efficiency and complexity. In this paper, this issue is addressed with a focus
on the problem of minimizing the total number of packets transmitted by the source and intermediate
nodes. Subsequently, the problem is formulated as a mixed integer nonlinear programming (MINLP)
problem that is NP-hard in general. By exploiting the properties of inner codes and the incomplete
beta function, we construct a nonlinear programming (NLP) problem that gives a valid upper bound
on the best performance that can be achieved by any feasible solutions. Moreover, both centralized and
decentralized real-time optimization strategies are developed. In particular, the decentralized approach is
performed independently by each node to find a feasible solution in linear time with the use of look-up
tables. Numerical results show that the gap in performance between our proposed approaches and the
upper bound is very small, which demonstrates that all feasible solutions developed in the paper are
near-optimal with a guaranteed performance bound.
Index Terms
Z. Zhou is with the National Key Laboratory of Science and Technology on Communications, University of Electronic Science
and Technology of China, Chengdu, China (e-mail: zhzhou@uestc.edu.cn).
C. Li is with the Department of Computer Science, City University of Hong Kong, Tat Chee Ave., Hong Kong SAR, China
(e-mail: congduan.li@cityu.edu.hk).
S. Yang is with the School of Science and Engineering, the Chinese University of Hong Kong (Shenzhen), Shenzhen, China
(e-mail: shyang@cuhk.edu.cn).
X. Guang is with the Institute of Network Coding, The Chinese University of Hong Kong, Hong Kong SAR, and the School
of Mathematical Sciences, Nankai University, Tianjin, China (e-mail: xuanguang@inc.cuhk.edu.hk).
September 5, 2017 DRAFT
ar
X
iv
:1
70
9.
00
58
8v
1 
 [
cs
.I
T
] 
 2
 S
ep
 2
01
7
2
Network coding, Batched sparse codes, Mixed integer nonlinear programming
I. INTRODUCTION
Multi-hop wireless networks have many applications, such as the wireless sensor networks,
the underwater networks and the vehicular networks. In these scenarios, a wireless device or a
source node would like to reliably transmit data to a destination node via multiple intermediate
relay nodes. However, severe packet losses may occur in wireless communications due to the
multipath effect, congestion, limited resources and hidden nodes. The more the number of hops
is, the higher the probability that a packet losses becomes. To provide end-to-end reliability in
multi-hop wireless networks, various techniques, such as retransmission [1], network coding [2]-
[4] and fountain codes [5][6], have been proposed to handle the packet loss. However, these
mechanisms are not efficient for multi-hop systems and lead to a waste of resources [8][15].
BATched Sparse (BATS) code [7] as a promising new technique, is proposed to achieve the
end-to-end reliable communications in multi-hop wireless networks. A BATS code consists of
outer code and an inner code [7]. The outer code is a matrix generalized fountain code to generate
a potentially unlimited number of batches. Each batch consists of M coded packets. At each
forwarding node (including the source node), a random linear network code as an inner code is
used for the packets of the same batch in order to overcome the accumulation of the packet loss
over multi-hop transmissions. The inner code directly affects the empirical rank distribution that
plays a crucial role for the design of the outer code. The destination node can utilize a belief
propagation (BP) decoder to retrieve the source messages from the received batches with low
complexity.
BATS codes preserve the salient feature of fountain codes, in particular, the rateless property,
which can significantly reduce the number of acknowledgements and avoid retransmission. On the
other hand, with the use of relatively small batch size, BATS codes have lower encoding/decoding
complexity and less caching requirements in the intermediate nodes, compared with the ordinary
random linear network coding schemes [3]. Moreover, BATS codes generally achieve higher rates
than some other low-complexity random linear network coding schemes, such as EC codes [10]
and Gamma codes [12].
As a crucial component of BATS code, the design of inner codes has received widely atten-
tions [11][17]. Tang et al. [11] pointed out that the random scheduling scheme is not efficient for
inner codes in line networks, and instead presented an adaptive scheduling method to optimize
September 5, 2017 DRAFT
3
the end-to-end throughput. Yin et al. [17] further designed an algorithm, named Adaptive
Recoding (AR), where each intermediate node chooses the number of coded packets of a batch
in accordance with both its rank and the rank distribution of all received batches. In [17], the
authors also numerically computed the throughput on line networks with the assumption that all
nodes can communicate simultaneously.
However, in the context of wireless networks, not all nodes within a certain area (e.g., sender
and its neighbors) can transmit data at the same time due to the limited bandwidth resources. In
order to efficiently utilize bandwidth resources to support high throughput, the total number of
packets transmitted along a flow path should be carefully considered. In addition to bandwidth
constraint, wireless nodes are typically powered by batteries that are of limited capacity and
even non-replaceable in many applications. One of the biggest consumers of energy is data
transmission [18][19]. Hence, communication cost highly depends on the number of packets
sent. Therefore, it is important to optimal the total number of transmitted packets between
source and destination to save energy and improve network lifetime.
In this paper, we investigate the optimal inner code problem for BATS code in multi-hop
wireless networks, with the objective of minimizing the expected number of transmissions from
the source to the destination node. The problem is formulated as a Mixed Integer NonLinear
Programming (MINLP) problem, which is typically difficult to solve. To bypass the difficulty,
we investigate the inherent structures in the inner codes and develop an upper bound on the
optimal solution. In the meantime, the centralized and decentralized real-time optimization
approaches are proposed. By using these approaches, the total number of transmissions can
be significantly reduced as well as achieving the high transmission efficiency. Our results fill
in some important gaps in the current understandings on optimizing the inner codes in wireless
networks. Specifically, four major contributions of this paper are as follows.
• We establish the relation between the empirical rank distribution and the total number
of transmission. By using the recursive expression of the rank distribution, we show that
minimizing the total number of transmissions can be formulated as an MINLP problem. To
the best of our knowledge, this is the first attempt to investigate the number of transmissions
from an end-to-end point of view for BATS codes.
• We model the channel as an one-step Markov process. Based on the property of the
eigen-decomposition of the transition matrix, the explicit formula for evaluating the rank
distribution is derived. Further, by utilizing both the explicit formula and the incomplete
September 5, 2017 DRAFT
4
beta function [21], a NonLinear Programming (NLP) problem is constructed. We, then,
prove that this NLP provides a valid upper bound on the optimal value of the MINLP.
• We propose both centralized and decentralized real-time optimization stategies for designing
the inner codes in multi-hop wireless networks. The centralized scheme is performed by the
source only, while the decentralized one with linear complexity is independently operated
by each node. More specifically, each node solves the optimization problem by means of the
look-up tables that are built from the properties of the objective function and the information
obtained from its next hop. In addition, a variation of the look-up table designed to adapt
to the dynamic networks, is also discussed.
• We show that the proposed approaches yield an objective value very close to the upper
bound, which indicates that our approaches can offer the near-optimal solutions. We also
evaluate the performance of the proposed approaches on the average rank of the received
batches, which provides some guidelines for future algorithm and protocol designs in
practical networks.
The remainder of the paper is organized as follows. In §II, we start with a brief introduction
to the BATS codes and the related works. In §III, the network model is discussed with the
formulation of the MINLP problem. §IV establishes a NLP problem by relaxing integrity
constraint of the MINLP. In addition, the practical schemes to find the optimum in centralized and
distributed methods are proposed, respectively. In §V, extensive simulation results are presented
to illustrate that the real-time approaches presented in §IV are able to offer near-optimal solution.
§VI concludes the paper.
II. BACKGROUND
A. Batched Sparse Codes
A BATS code consists of an outer code and an inner code. The outer code is only performed
by source nodes. Suppose a source node needs to send N input packets to a destination node via
a wireless network, where each symbol of a packet is an element of the finite field Fq, where q
is a prime power. Fix an integer M ? 1 as the batch size. Using the outer code, a sequence of
batches Xi, i = 1, 2 . . . are generated as,
Xi = Bi ·Gi,
September 5, 2017 DRAFT
5
where Bi is a matrix consisting of dgi columns, each of which is a source packet that is randomly
picked out, and Gi is a totally random matrix on Fq of size dgi ×M , i.e., each entry of Gi is
independently and uniformly chosen from Fq. Here, dgi is called the degree of the i-th batch Xi.
The degrees dgi, i = 1, 2, . . . , are independent identically distributed (i.i.d.) random variables
with a given distribution ? = (?1, ...,?N), i.e., Pr{dgi = n} = ?n, 1 ? n ? N .
Before transmitting batch Xi, the source node performs random linear network coding on
packets belonging to the batch. When an intermediate node receives a batch, the node will also
apply random linear network coding to the batch and, then, forward it. The procedure is called
inner coding (or recoding).
In particular, the batch Yi received by a node can be expressed as
Yi = Xi ·Hi,
where Hi is called transfer matrix. After the destination node receives enough batches, the source
packets can be efficiently decoded by using belief propagation (BP).
B. Related Works
Ng et al. [13] studied the performance of finite-length BATS codes with respect to BP
decoding. In [8], [14] and [15], the authors proposed a BATS-based network protocol and
evaluated the performance over lossy channels. In particular, Yang et al. [8] designed a simple
packet interleaving scheme to combat against the bursty losses. In the mean time, Huang et al.
[14] proposed a FUN framework, where an inner-encoding algorithm was designed to mix the
packets belonging to two intersecting flows. Zhang et al. [15] further extended their previous
work [14] and indicated both theoretically and practically that their algorithms performed better
than the exiting approaches in TDMA multi-hop networks. In [16], the authors proposed a
distributed two-phase cooperative broadcasting protocol, which uses BATS codes in the first
phase to help the peer-to-peer (P2P) communications.
III. SYSTEM MODEL AND PROBLEM FORMULATION
A. Network Model
We consider a multi-hop wireless network where one source node intends to deliver packets to
one sink node. Both source and sink nodes are arbitrarily placed in the network, while the sink
node is out of the transmission range of the source. Consequently, the end-to-end transmission
September 5, 2017 DRAFT
6
v1
vl+1
v2
vk
vl
1 l
Fig. 1: The network with an unicast flow.
needs help from intermediate nodes. The communication process consists of two phases: the
initial phase and the transmission phase.
In the initial phase, the source node establishes a path to the sink node by means of a single-
path routing protocols (e.g., DSDV [25]). For instance, the path can be described as Fig. 1,
which consists of l+ 1, l > 0 nodes vk, 1 ? k ? l+ 1. Nodes v1 and vl+1 denote the source and
sink, respectively. In addition, the source collects the quality of each link, e.g., packet loss rate
(PLR). Let vkvk+1 (or k for short) denote the PLR from node vk to node vk+1. In the model,
we consider that packet losses are governed by i.i.d. Bernoulli processes.
In the transmission phase, the source generates and sends a set of message packets to the sink
node along the path. The source packets are encoded by a BATS code. More specifically, the
source performs both the outer and inner encoding, while the intermediate nodes only recode their
received packets by means of an inner code. Let Xin be a batch cached by node vk, 1 ? k ? l,
then the inner code can be expressed by
Xout = Xin ·?, (1)
where the elements of matrix ? are independently and randomly chosen from some finite field.
We call ? totally random coding matrix (or coding matrix for short). As we will show that the
number of columns of ? is closely related to the performance of a BATS code.
In addition, only the end-to-end ACKs are allowed during the transmissions in the last phase.
It is postulated that the route remains available until the traffic session is closed.
B. Problem Formulation
Let nk be the number of batches transmitted by node vk, 1 ? k ? l. Let index set ?k consist
of the indices of batches received by node vk(1 ? k ? l + 1) and, particularly, ?1 ? ?2 ?
September 5, 2017 DRAFT
7
· · · ? ?l+1. Let tk,i be the number of coded packets generated by node vk for the i-th batch
(i ? ?k). In this paper, we let node vk generate the same number of coded packets, say tk, for
every received batch in ?k, i.e., tk,i = tk, ? i ? ?k.
Since every batch sent by node vk consists of tk coded packets, the total number Ttotal of
packets transmitted by the source node and all the intermediate nodes during the communication
is
Ttotal =
l?
k=1
nktk.
In this paper, our goal is to minimize Ttotal as mentioned before that it is closely related
to the wireless network performance such as throughput and energy. Toward this end, we need
determine the optimal values of nk and tk. It is worth to note that each node can only process the
batches they received. Since packet losses are i.i.d. as well as batches are generated independently
by node vk, the number nk+1 of batches received by vk+1 can be evaluated to nk+1 = nk(1?tkk ).
Thus, we obtain
Ttotal = n1
l?
k=1
k?
i=1
(1? tii )tk (2)
After the both sides of Eq. (2) are normalized by the number of source packet, we define
transmission efficiency as
? =
N
Ttotal
=
N
n1
· 1?l
k=1
?k
i=1(1? 
ti
i )tk
.
Suppose that the empirical rank distribution of the transfer matrices converging to hk =
[hk,0, hk,1, . . . , hk,M ] at node vk, 1 ? k ? l + 1. In particular, h1 = [0, 0, . . . , 0, 1] at the source
node. All vectors are column vectors throughout this paper. Then, we can design an outer code
such that the coding rate N/n1 ?
?M
r=1 rhl+1,r , ~l+1 when N is sufficiently large [7]. In
this paper, we use the average rank ~l+1 to approximate N/n1 and, then, redefine transmission
efficiency ? as
? =
~l+1?l
k=1
?k
i=1(1? 
ti
i )tk
. (3)
Next, let us show how to estimate ~l+1 by means of ti, 1 ? i ? l. We have the following
theorem.
Theorem 1: Let
?n,mr =
?nr ?
m
r
?rr q
(n?r)(m?r) , (4)
September 5, 2017 DRAFT
8
and
?nr =
?????
r?1?
i=0
(1? q?n+i), r > 0;
1, r = 0.
(5)
Then the probability that the rank of transfer matrices obtained by node vk+1, k = 1, 2, . . . , l, is
r is
hk+1,r =
M?
m=r
tk?
n=r
hk,m
(
tk
n
)
(1? k)n tk?nk ?
n,m
r , (6)
under the boundary condition h1 = [0, · · · 0, 1].
Proof: The proof is given in Appendix A.
Clearly, the average rank ~i is a function of tj, j = 1, 2, . . . , i? 1, with given M and q. Now,
we construct the optimization problem P1 as follows.
P1 : maximize
t1,··· ,tl
? =
~l+1?l
k=1
?k
i=1(1? 
ti
i )tk
=
?M
r=0 rhl+1,r?l
k=1
?k
i=1(1? 
ti
i )tk
subject to Equation (6),
tk ? N, tk > 0, k = 1, . . . , l.
Problem P1 is a mixed integer nonlinear programming (MINLP) problem, which is usually
NP-hard [26]. Though there exist some tools (e.g., NOMAD [27], and Genetic Algorithm (GA)
[28] in MATLAB) to solve such problems, we find they cannot guarantee a good solution in
reasonable time for a moderate number of intermediate nodes, e.g., l > 5. In particular, the
solvers based on the branch-and-bound technique, such as KNITRO [29], are not suitable for
problem P1. It is due to the fact that Eq. (6) must operate on natural numbers. Therefore, we
need to propose some practical methods to address our problem.
Remark 1: The authors in [11] and [17] illustrated that ~l+1 can be further improved by making
different recoding decisions, i.e., the number of coded packets of a batch, for different batches
with respect to their ranks. However, these approaches inevitably bring extra computations due
to the rank detection. In this paper, we are interested in achieving the maximum ? by optimizing
tk, k = 1, . . . , l without considering the rank of each batch.
September 5, 2017 DRAFT
9
IV. MAIN RESULTS
In this section, we aim to efficiently solve the MINLP problem described above. We explore
some inherent properties of the inner code described in Eq. (1). By combining the properties with
the incomplete beta function, we establish an NLP problem, called PU, that provides a valid
upper bound of the optimal value of P1. The upper bound is used as a direct measurement for our
practical approaches. In the last part of this section, we present the centralized and decentralized
optimization strategies that can produce the near-optimal solutions of P1 in real-time.
A. Properties
Let us present in the following analysis to compute the rank distribution in a matrix fashion.
For 1 ? k ? l, 0 ? n ? tk, we let
f(k, n) =
(
tk
n
)
(1? k)n tk?nk .
After substituting f(k, n) into (6), we get
hk+1,j =
M?
m=j
tk?
n=j
hk,mf(k, n) ?
m,n
j
=hk,j
tk?
n=j
f(k, n)?j,nj + hk,j+1
tk?
n=j
f(k, n)?j+1,nj (7)
+ · · ·+ hk,M
tk?
n=j
f(k, n)?M,nj
=hTkp
k
j , 1 ? k ? l, 0 ? j ?M, (8)
where recall that hTk = [hk,0, hk,1, . . . , hk,M ] is the empirical rank distribution of the transfer
matrices as stated above Eq. (3) and, then, for j = 1, 2, · · · ,M ,
pkj =
[
0, . . . , 0,
tk?
n=j
f(k, n)?j,nj , . . . ,
tk?
n=j
f(k, n)?M,nj
]
,
otherwise, for j = 0,
pk0 =
[
1,
tk?
n=0
f(k, n)?1,n0 , . . . ,
tk?
n=0
f(k, n)?M,n0
]
.
September 5, 2017 DRAFT
10
The (i+ 1)-th component of pkj represents the probability of receiving a transfer matrix with
rank j given the transmitted matrix has rank i. We, then, model the channel as an one-step
Markov process with an (M + 1)× (M + 1) transition matrix,
Pk ,
[
pk0 p
k
1 · · · pkM
]
=
??????????
1 0 · · · 0
tk?
n=0
f(k, n)?1,n0
tk?
n=1
f(k, n)?1,n1 · · · 0
...
... . . .
...
tk?
n=0
f(k, n)?M,n0
tk?
n=1
f(k, n)?M,n1 · · ·
tk?
n=M
f(k, n)?M,nM
??????????
, 1 ? k ? l. (9)
By combining (7) and (9), we establish the following matrix formulas to estimate the rank
distribution and the average rank at node vk+1, respectively, for k = 1, 2, . . . , l as follows:
hTk+1 = h
T
k Pk = h
T
1
k?
i=1
Pi, (10)
and
~k+1 =
M?
r=1
rhk+1,r = hTk+1e = h
T
1
k?
i=1
Pie. (11)
where let e = [0, 1, . . . ,M ].
Next, we investigate the properties of the transition matrices. The following lemma indicates
that the transition matrices Pk, k = 1, 2, . . . , l, have the same eigenvectors, while the proof is
deferred in Appendix B.
Lemma 1: Each matrix Pk, 1 ? k ? l, can be eigendecomposed into
Pk = Q?kQ
?1, (12)
where ?k is a diagonal matrix with eigenvalues
?k,j =
?????1 j = 1,?tk
n=j?1 f(k, n)?
j?1,n
j?1 j = 2, 3, . . . ,M + 1,
(13)
and Q = [qi,j]1?i,j?M+1 is a lower-triangular matrix with entries
qi,j =
???????????
0 i < j,
1 j = 1,
? i?1j?1 otherwise
(14)
September 5, 2017 DRAFT
11
With the above discussion , it is convenient to reformulate Theorem 1 as follows.
Theorem 2: The rank distribution hk+1 and the expected rank ~k+1 can be derived by
hTk+1 = h
T
1Q
k?
i=1
?iQ
?1, (15)
~k+1 = hT1 Q
k?
i=1
?iQ
?1e, k = 1, 2, . . . , l, (16)
where ?k and Q equal to (13) and (14), respectively, and recall that e = [0, 1, . . . ,M ] and
h1 = [0, 0, . . . , 0, 1].
Now, let hT1Q = [?0, ?1, . . . , ?M ] and Q
?1e = [0, ?1, ?2, . . . , ?M ]
T. We transform P1 into
P1? : maximize
t1,··· ,tl
? =
?M
r=1 ?r?r
?l
k=1
?tk
n=r f(k, n)?
r,n
r?l
k=1
?k
i=1(1? 
ti
i )tk
,
subject to tk ? N, tk > 0, k = 1, . . . , l.
Notice that problem P1? is still an MINLP.
B. Upper Bound
Here, we relax the integer restrictions of P1? by using the regularized incomplete beta function
[21]. We first give the following lemma.
Lemma 2: Let i, m and n be three nonnegative integers with i ? min{m,n}. Then
lim
q??
?ni = 1, (17)
and
lim
q??
?m,ni =
?????1 i = min{m,n},0 otherwise. (18)
Proof: Equation (17) is obvious by Eq. (5) in Theorem 1.
For Eq. (18), if i = min{m,n},
?m,ni =
??????
n
m, if m < n,
?mn , otherwise,
which implies that Eq. (18) by Eq. (17). Otherwise, by Eqs. (4) and (5) in Theorem 1, we have
?m,ni =
?ni ?
m
i
? iiq
(m?i)(n?i)
=
?i?1
x=0(1? q?n+x)
?i?1
x=0(1? q?m+x)?i?1
x=0(1? q?i+x)q(m?i)(n?i)
,
September 5, 2017 DRAFT
12
which immediately implies that limq?? ?
m,n
i = 0, completing the proof.
Next, let us rewrite Eq. (6) as
hk+1,j =
M?
m=j+1
hk,mf(k, j)?
m,j
j + hk,j
tk?
n=j
f(k, n)?j,nj
+
M?
m=j+1
tk?
n=j+1
hk,mf(k, n)?
m,n
j . (19)
Let h?k+1 = [h?k,0, h?k,1, . . . , h?k,M ]. By assuming q being sufficiently large and applying Lemma
2 to Eq. (19), we, then, use the following equation to approximately calculate the rank distribution
hk+1,
h?k+1,j =
M?
m=j+1
h?k,mf(k, j) + h?k,j
tk?
n=j
f(k, n). (20)
In particular, h?1 = h11. Similar to Eqs. (10) and (11), the distribution h?k+1 and the corre-
sponding expected ~?k+1 ,
?M
r=1 rh?k,r can be expressed, respectively, as
h?Tk+1 = h?
T
k P?k = h?
T
1
k?
i=1
P?i, k = 1, . . . , l, (21)
and
~?k+1 = h?Tk+1e = h?T1
k?
i=1
P?ie. (22)
where, the transition matrices P?k, k = 1, 2, . . . l, are given by
P?k ,
?????????????
1 0 · · · 0 0
tk
tk?
n=1
f(k, n) · · · 0 0
tk f(k, 1) · · · 0 0
...
... . . .
...
...
tk f(k, 1) · · · f(k,M ? 1)
tk?
n=M
f(k, n)
?????????????
.
Then, we have the following theorem.
Theorem 3: The approximate expected rank ~?k+1 can be derived by
~?k+1 =
M?
r=1
k?
j=1
I1?j(r, tj ? r + 1), tj ? N. (23)
1When q ? 24, the difference between ~k and ~?k, k > 0, is less than O(10?2)
September 5, 2017 DRAFT
13
where
I1?j(r, tj ? r + 1) =
? 1?j
0
xr?1(1? x)tj?rdx? 1
0
xr?1(1? x)tj?rdx
Proof: Similar to Lemma 1, it can be verified that
P?k = Q???kQ?
?1,
where ??k is a diagonal matrix with eigenvalues
??k,j =
?????1 j = 1,?tk
n=j?1 f(k, n) j = 2, 3, . . . ,M + 1,
and Q? is a sum matrix whose inverse Q??1 is a difference matrix,
Q? =
??????????
1 0 0 · · · 0 0
1 1 0 · · · 0 0
...
... . . .
...
...
1 1 1 · · · 1 0
1 1 1 · · · 1 1
??????????
and
Q??1 =
??????????
1 0 0 · · · 0 0
?1 1 0 · · · 0 0
0 ?1 1 · · · 0 0
...
...
... . . .
...
...
0 0 0 · · · ?1 1
??????????
.
In particular, note that
h1Q? = [1, 1, . . . , 1],
Q??1e = [0, 1, 1, . . . , 1]T.
Then, by Eq. (22) we obtain that for k = 1, 2, . . . , l,
~?k+1 = h?T1Q?
k?
i=1
??iQ?
?1e
=
M?
r=1
k?
j=1
tj?
n=r
f(j, n).
September 5, 2017 DRAFT
14
Furthermore, by using the following property of the regularized incomplete beta function, the
proof is completed.
I1?j(r, tj ? r + 1) =
tj?
n=r
(
tj
n
)
(1? j)n 
tj?n
j
=
tj?
n=r
f(j, n), tj, r ? N.
Now, with Eq. (23), we construct the following formulation,
~?l+1?l
k=1
?k
i=1(1? 
ti
k )tk
=
?M
r=1
?l
k=1 I1?i(r, tk ? r + 1)?l
k=1
?k
i=1(1? 
ti
i )tk
. (24)
It is worth to notice that the parameter tj in I1?k(r, tk?r+1) does not need to be an integer.
Hence, we establish a new optimization problem as follows,
PU : maximize
t1,··· ,tl
?M
r=1
?l
k=1 I1?k(r, tk ? r + 1)?l
k=1
?k
i=1(1? 
ti
i )tk
subject to tk > 0, k = 1, . . . , l.
For this nonlinear programming problem, we have the following theorem whose proof is
deferred to Appendix C.
Theorem 4: Problem PU yields an upper bound of the optimal value of problem P1 (or
P1?).
However, the solutions of Problem PU are not feasible for P1 since their values in general are
not integers. Therefore, we still need to develop some practical schemes to solve our problem.
C. Real-Time Implementations
First, we design a centralized approach by constructing the following optimization problem.
P2 : maximize
t1,··· ,tl
?M
r=1 ?r?r
?l
i=1
?ti
n=r f(i, n)?
r,n
r?l
k=1
?k
i=1(1? 
ti
i )tk
,
subject to tuk ? tk ? tdk, tk ? N, k = 1, 2, . . . , l.
where u = [tu1 , . . . , t
u
l ] and d = [t
d
1, . . . , t
d
l ] are computed by Algorithm 1. The problem P1
? and
P2 have the same objective function. Nevertheless, the feasible region of P2 is finite and, more
specifically, contains 2l elements at most. Various MINLP solvers, such as NAMOD and GA,
September 5, 2017 DRAFT
15
Algorithm 1 Finding boundary for tk
Input: M , l, 1, 2, . . . , l;
Output: u and d;
1: t?? arg min ??;
2: u? dt?e;
3: d? bt?c;
4: return u, d;
S
18
18
R
18
16
D
? = 2.68
?? = 2.50
0.2
0.2
0.2
0.1
Fig. 2: The 2-hop network, M = 16. The optimal solutions of P2 for packet loss rates (0.2,0.2)
and (0.2,0.1) are (18,18) and (18,16), respectively.
can solve P2 in reasonable time. Thus, the source can use the network information gathered in
the initial phase to compute the solutions of P2 in real-time.
For the centralized approach, one question should be asked: how to send the solutions to the
intermediate nodes. One possible way is to put them into the packet header or construct a new
control packet containing the information. Either way, it inevitably takes extra overhead. Also,
this global estimate may degrade the network performance in the presence of the time-varying
network. For example, as shown in Fig. 2, suppose PLRs change from (0.2, 0.2) to (0.2, 0.1) in
the transmission phase. Using the centralized method, intermediate node R is unable to timely
adapt to such a change, resulting in (18? 16) ? 100%/16 = 12.5% more packets transmitted.
To overcome the above problems, we propose a decentralized method, such that each node
makes their own inner coding decisions locally and independently. First, we have to face the
question that how to solve problem P1 (or P1?) locally, i.e., how nodes choose the parameters
M, l, 1, 2, . . . , l, based on their own knowledge of the network. Obviously, the problem is
trivial when every node can obtain the global information. However, in real system, nodes may
only be able to gather network information within a certain range. In particular, we assume that
September 5, 2017 DRAFT
16
each node can only acquire 1-hop packet loss rates from its neighbors.2 Further, let us suppose
that both the number of hops l, and the batch size M are contained in packet header, which do
not cost too much. Then, the remaining question is how to set packet loss rates 1, . . . , l. Our
solution is inspired by the following facts.
We notice that the probabilities pi, i = 1, 2, . . . , l, are very close to 1, when the batch size
M ? 8. Therefore, we set pi = 1, i = 1, 2, . . . , l, and, then, construct the resulting optimization
problem PA.
PA : maximize
t1,··· ,tl
?M
r=1 ?r?r
?l
i=1
?ti
n=r f(i, n)?
r,n
r?l
k=1 tk
subject to tk ? Z, tk > 0, k = 1, 2, . . . , l.
Remark 2: The solutions of PA well match these of P1, even when q = 2 and M = 8. This is
because, the optimal solutions for both PA and P1 are all larger than M and increase with both
path length and PLR. As a results, the product of (1? tik ) will be very close to 1 in such cases.
For example, given l = 100, 1 = 2 = · · · = l = 0.35, q = 2 and M = 8, then the optimal
solution for both PA and P1 is t?1 = · · · = t?l = 25, and
?100
i=1(1 ? 25k ) = 0.99999991. In the
meanwhile, the difference between the objective values of PA and P1 is less than O(10?5).
Then, the following proposition is derived from problem PA.
Proposition 1: Let {t?i , i = 1, 2, . . . , l}, be the optimal solution for PA. If 1 = 2 = · · · = l,
then t?1 = t
?
2 = · · · = t?l .
Proof: Let  = i and t = ti, i = 1, 2, . . . , l. We define
?? =
?M
r=1 ?r?r
(?t
n=r
(
t
n
)
(1? )n t?n?r,nr
)l
lt
=
?M
r=1 ?r?rg
l(r, t)
lt
, t ? N, t > 0.
where
g(r, t) =
t?
n=r
(
t
n
)
(1? )n t?n?r,nr .
Let t? = arg maxt ??. Then for any feasible t,?M
r=1 ?r?rg
l(r, t?)
lt?
?
?M
r=1 ?r?rg
l(r, t)
lt
. (25)
2Periodic Hello messaging can be used to perform this task.
September 5, 2017 DRAFT
17
By taking t1, t2, . . . , tk into Eq. (25) and adding them up, we write?M
r=1 ?r?rg
l(r, t?)
lt?
(
l?
i=1
lti
)
?
M?
r=1
?r?r
(
l?
k=1
gl(r, tk)
)
(a)
?
M?
r=1
?r?rl
l
?
gl(r, t1)gl(r, t2) · · · gl(r, tl)
=
M?
r=1
?r?rl
l?
k=1
g(r, tl).
where (a) follows the arithmetic-geometric mean inequality. The above equation implies?M
r=1 ?r?rg
l(r, t?)
lt?
?
?M
r=1 ?r?r
?l
k=1 g(r, tl)?l
k=1 tk
,
?ti > 0, i = 1, 2, . . . , l
The proof is completed.
Corollary 1: Let {t?i , i = 1, 2, . . . , l}, be the optimal solution for PA. If i1 = i2 = · · · = in ,
then t?i1 = t
?
i2
= · · · = t?in , 1 ? ik ? l, 1 < k ? n ? l.
Proof: We consider n < l and define two index sets ? = {1, 2, . . . , l} and ?? = {i1, i2, . . . , in}.
Then, the objective function of PA can be rewritten as follows
?? ,
T +
?
i??? ti?M
r=1 ?r?r?r
?
i???
?ti
n=r f(i, n)?
r,n
r
,
where T =
?
i??/?? t
?
i and ?r =
?
i??/??
?t?i
n=r f(i, n)?
r,n
r are constants. Now, we can apply the
method in Proposition 1 to prove this corollary.
Subsequently, we construct a single variable optimization problem as follows.
PS : maximize
t
?M
r=1 ?r?r
(?t
n=r
(
t
n
)
(1? )n t?n?r,nr
)l
lt
subject to t > 0, t ? Z.
Nodes vi, i = 1, 2, . . . , l, can input  = i to PS, and use the outputs to make their own coding
decisions. From Table I, of which each element is the solution for PS with a pair of PLR and
the number of hops, we observe that the difference between any two adjacent elements is at
most 1. It suggests that we can build a 4-D look-up table for q, M , and use a fixed step size
of 0.01 and 1 for  and l, respectively. Therefore, nodes can use the look-up table to make the
appropriate decisions by matching the current situation, i.e., q, M , l and , to the most similar
of the entries already in the table. The time complexity of this table look-up algorithm is only
September 5, 2017 DRAFT
18
TABLE I: The look-up table, q = 28, M = 16
The number of hops
PLR 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
0.10 16 17 17 18 18 18 18 19 19 19 19 19 19 19 19 19 19 20 20
0.11 17 17 18 18 18 19 19 19 19 19 19 19 20 20 20 20 20 20 20
0.12 17 17 18 18 19 19 19 19 19 19 20 20 20 20 20 20 20 20 20
0.13 17 18 18 19 19 19 19 19 20 20 20 20 20 20 20 20 20 21 21
0.14 17 18 18 19 19 19 20 20 20 20 20 20 20 21 21 21 21 21 21
0.15 17 18 19 19 19 20 20 20 20 20 21 21 21 21 21 21 21 21 21
0.16 17 18 19 19 20 20 20 20 21 21 21 21 21 21 21 21 22 22 22
0.17 17 18 19 20 20 20 20 21 21 21 21 21 21 22 22 22 22 22 22
0.18 18 19 19 20 20 21 21 21 21 21 22 22 22 22 22 22 22 22 22
0.19 18 19 20 20 21 21 21 21 22 22 22 22 22 22 22 22 23 23 23
0.20 18 19 20 20 21 21 21 22 22 22 22 22 23 23 23 23 23 23 23
O(1) at each node. In addition, Table I can be further compressed by eliminating the repeated
elements.
Remark 3: There are many choices to set packet loss rates 1, 2, . . . , l and construct the
corresponding look-up tables. For example, since node vi knows i?1, we can set vk = vi, k =
1, 2, . . . , l, k 6= i ? 1. As another example, since node vi can computer the empirical rank
distribution of the batches it received, only k, k = i + 1, . . . , l, need be set. However, these
methods may lead to a very large table costing a lot of resources. As we shall see in the next
section, the proposed method already achieves a near-optimal performance by comparing with
the upper bound.
In the above discussion, we assume that the number of hops, l, can be determined precisely by
routing policy. However, in real systems, the routing protocol may only return an approximate
value of l, or the intermediate nodes may change in the transmission phase. It results in
lengthening or shortening the path length. Therefore, setting l to be an fixed value may cause
inaccuracy. Our solution of this problem is based on the following facts.
Proposition 2: Given , postulate that t?1 and t
?
2 are the optimal solutions for PS with
parameters l1 and l2, respectively. If l1 < l2, then t?1 ? t?2.
Proof: The proof is given in Appendix D.
Corollary 2: Given 1, 2, . . . , l, t1, t2, . . . , tl and t?1, t?2, . . . , t?l. If ti ? t?i, ?i = 1, 2, . . . , l,
September 5, 2017 DRAFT
19
TABLE II: The refined look-up table, q = 28, M = 16
The number of hops
PLR 2 4 7 11 16 20
0.10 16 17 18 19 19 20
0.11 17 18 19 19 20 20
0.12 17 18 19 19 20 20
0.13 17 18 19 20 20 21
0.14 17 18 19 20 21 21
0.15 17 19 20 20 21 21
0.16 17 19 20 21 21 22
0.17 17 19 20 21 22 22
0.18 18 19 21 21 22 22
0.19 18 20 21 22 22 23
0.20 18 20 21 22 23 23
then
Pr{rk(Hi) ? r} ? Pr{rk(H?i) ? r},
where the transfer matrices Hi and H?i are related to t1, t2, . . . , ti and t?1, t?2, . . . , t?i, respectively.
The above results suggest that we can set a range of the number of hops for a path, and
choose the largest value among them as the parameter l inserted into packet headers. In this
way, it can provide a “good” rank distribution (higher average rank) if the length of a path is
within the range. In this paper, we construct the look-up tables, called Refined Lookup Table
(RLT), by only keeping the 2nd, 4th, 7th, 11th, 16th and 20th columns of the CLTs. Table II gives
an instance of RLTs. With RLTs, the source will build the nearest (and larger) l listed in RLT
into packet headers according to the routing information. For example, the value l = 7 will be
inserted into packet headers, if the number of hops reported by the routing protocol is larger
than 2 but no more than 7. In the next section, the simulation results will show that the use of
RLT causes only a little loss in the performance.
V. NUMERICAL RESULTS AND DISCUSSION
In this section, we present numerical experiments to evaluate the performance of the proposed
algorithms, and demonstrate the improvement compared to the original BATS codes [7].
September 5, 2017 DRAFT
20
The unicast wireless networks described in Section III is considered. We assume that the links
are heterogeneous. More specifically, each node may experience different packet loss rate (PLR).
In the experiments, network size l ranges from 2 to 20, and batch size M is set to 12, 16, 20
and 24, respectively. For a combination of l and M (e.g l = 2,M = 12), we run 10000 trials,
in each of which packet loss rates are randomly chosen from a uniform distribution over the
interval [0.05,0.35]. The loss rates remain constant over each trial. Figures are, then, derived from
average analytical results. The simulations are run in MATLAB, and all optimization problems
are solved by means of the optimization toolbox.
In particular, we separately test two classes of the look-up tables for the decentralized approach.
One uses a fixed step size of 1 for the number of hops, called complete look-up tables, such as Ta-
ble I. Another class of tables, called refined look-up table, contains only the 2nd, 4th, 7th, 11th, 16th
and 20th columns of the CLTs.
A. Transmission Efficiency
In the first set of experiments, we would like to check the performance of the original BATS
(denoted by OBATS) codes [7] and the upper bound (denoted by Upper) in terms of transmission
efficiency. We set the field size q = 28. Notice that the performance of the original BATS codes
can be barely improved by increasing the field size to q ? 28. The batch transmission efficiency
is depicted in Fig. 3a, and more specifically, Fig. 3b illustrates the percentage of improvement
of transmission efficiency compared to OBATS. The transmission efficiency reduction = [Upper
- OBATS] × 100 / OBATS.
Next, we use the upper bound as the performance benchmark to test our proposed algorithms.
In the simulation, we set the field size q = 24 and q = 28, respectively. We use PA, CLT and RLT
to denote the centralized, the CLP-based and the RLT-based real-time approach, respectively. The
mean relative gap between the real-time approach and the upper bound is defined by [Upper -
PA (CLT or RLT)] × 100 / Upper. Results are depicted in Fig. 4. In general, we observe that
all the approximating solutions closely match the upper bound. More importantly, the look-up-
table-based approximations achieve extremely competitive performance with the upper bound,
but with a constant computational cost. In particular, the transmission efficiency are very similar
in the two table look-up algorithms.
Combining Fig. 3 with Fig. 4, the improvement of the proposed methods can clearly seen in
all cases, i.e., for all kind of batch size and network size. Therefore, according to the discussion
September 5, 2017 DRAFT
21
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Hops
10-1
T
ra
ns
m
is
si
on
 E
ffi
ci
en
cy
Upper, M=12
Upper, M=16
Upper, M=20
Upper, M=24
OBATS, M=12, q=28
OBATS, M=16, q=28
OBATS, M=20, q=28
OBATS, M=24, q=28
(a) Transmission efficiency
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Hops
2
4
6
8
10
12
14
16
18
20
T
ra
ns
m
is
si
on
 e
ffi
ci
en
cy
 r
ed
uc
tio
n 
(%
)
M=12
M=16
M=20
M=24
(b) Reduction compared to the original BATS
Fig. 3: Transmission efficiency vs the number of hops under different batch size.
in Section III, it confirms that the total number of transmissions can be significantly reduced by
adjusting the values of ti, i = 1, . . . adapting to the current channel conditions.
Besides, Fig. 4 also presents that the gap between the approximating results and the upper
bound gets smaller with the increase of the number of hops as well as the batch size. On the other
hand, we also observed that the curves corresponding to the RLT-based approach are sharper
when the path length is smaller than 12, while they become smoother at longer length. These
observations illustrate that the transmission efficiency is more sensitive when the number of hops
September 5, 2017 DRAFT
22
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Hops
0.2
0.4
0.6
0.8
1
1.2
1.4
T
he
 m
ea
n 
re
la
tiv
e 
ga
p 
(%
)
PA, q = 24
CLT, q = 24
RLT, q = 24
PA, q = 28
CLT, q = 28
RLT, q = 28
(a) M = 12
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Hops
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
1.1
T
he
 m
ea
n 
re
la
tiv
e 
ga
p 
(%
)
PA, q = 24
CLT, q = 24
RLT, q = 24
PA, q = 28
CLT, q = 28
RLT, q = 28
(b) M = 16
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Hops
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
T
he
 m
ea
n 
re
la
tiv
e 
ga
p 
(%
)
data1
data2
data3
data4
data5
data6
(c) M = 20
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Hops
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
T
he
 m
ea
n 
re
la
tiv
e 
ga
p 
(%
)
PA, q = 24
CLT, q = 24
RLT, q = 24
PA, q = 28
CLT, q = 28
RLT, q = 28
(d) M = 24
Fig. 4: The mean relative gap vs the number of hops under different batch size. The lines marked
by P3, CLT and RLT represent the P3-based, CLT-based, RLT-based algorithms, respectively.
is relatively small.
B. The Average Rank
In this subsection, we investigate another important characteristic of BATS codes, i.e., the
average rank of transfer matrix at the destination node, which determines that the least number
of batches need be generated at the source. For the purpose of brevity, we only compare the
September 5, 2017 DRAFT
23
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Hops
5
6
7
8
9
10
11
12
T
he
 a
ve
rg
e 
ra
nk
 a
t t
he
 d
es
tin
at
io
n 
no
de Max RLT, q = 24
Min RLT, q = 24
Max RLT, q = 24
Mean OBATS, q = 28
Max OBATS, q = 28
Min OBATS, q = 28
(a) M = 12
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Hops
7
8
9
10
11
12
13
14
15
16
T
he
 a
ve
ra
ge
 r
an
k 
at
 th
e 
de
st
in
at
io
n 
no
de Mean RLT, q = 24
Min RLT, q = 24
Max RLT, q = 24
Mean OBATS, q = 28
Max OBATS, q = 28
Min OBATS, q = 28
(b) M = 16
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Hops
9
10
11
12
13
14
15
16
17
18
19
20
T
he
 a
ve
rg
e 
ra
nk
 a
t t
he
 d
es
tin
at
io
n 
no
de Mean RLT, q = 24
Min RLT, q = 24
Max RLT, q = 24
Mean OBATS, q = 28
Max OBATS, q = 28
Min OBATS, q = 28
(c) M = 20
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Hops
12
14
16
18
20
22
24
T
he
 a
ve
rg
e 
ra
nk
 a
t t
he
 d
es
tin
at
io
n 
no
de Mean RLT, q = 2
4
Min RLT, q = 24
Max RLT, q = 24
Mean OBATS, q = 28
Max OBATS, q = 28
Min OBATS, q = 28
(d) M = 24
Fig. 5: The average rank vs the number of hops under different batch size.
RLT-based algorithm3 with the original BATS, and set the field size q = 24 for the former while
q = 28 for the latter.4
3The average ranks between the RLT-based and CLT-based algorithm are very similar.
4We also observe that the average ranks of the RLT-based algorithm are very close when q = 24 and q = 28. Therefore, only
the values corresponding to q = 24 are plotted due to the lower complexity.
September 5, 2017 DRAFT
24
The first thing to note is that the average rank of our proposed approach is close to the batch
size, and the change trend goes up with the length of path. In the meanwhile, OBATS leads to
smaller average ranks that decrease with the number of hops. For the purpose of illustration,
the dash and dash-dot lines that represent the smallest and the largest values in the sample,
respectively, are also plotted in Fig. 5. Obviously, the fluctuation of the average rank generated
by our proposed approach are much smoother than that by OBATS.
In practical systems, the question of “When to stop generating batches at sources”, which
critically depends on the rank distribution, is crucial to the implementation of BATS codes. It is
very difficult to solve this problem due to the complex environment. For example, since there
exist multiple paths in multicast networks, the number of batches generated by the source is
determined by the path with the smallest average rank at destination node. Hence, if the average
ranks at sink nodes are far apart from each other, the performance for the pathes with large
average rank may suffer significant loss. The reason is that intermediate nodes belonging to
such pathes will process much more batches than expected.
The results in Fig. 5 suggest us a potential way of answering the question mentioned above.
Since the average ranks by our approximating methods are very close, the numbers of batches
related to different network conditions are likely to be close. However, we should note that, there
is still, unfortunately, a considerable gap between the minimum and maximum ranks. Therefore,
how to bridge the gap needs to be investigated further with other complementary methods, such
as to take into account a tradeoff between the number of batches and the number of coded packets
of a batch at intermediate nodes. More detailed descriptions of this issue will be addressed in
our future work.
C. The number of transmission
Finally, Fig. 6 provides the overall total number of transmission required to deliver a batch
from the source node to the destination node, i.e., ttotal =
?l
k tk,. It can be observed that, though
the RLT-based algorithm requires more transmissions than the original method with the same
batch size M , our approach provide higher transmission efficiency. It is worth to point out that
even if the original BATS code uses a greater M , our approach still has a good performance
in terms of both the transmission efficiency and average rank. This fact indicates that making
coding decision with current condition can lead to better outcomes.
September 5, 2017 DRAFT
25
2 4 6 8 10 12 14 16 18 20
Hops
0
100
200
300
400
500
600
700
T
he
 n
um
be
r 
of
 tr
an
sm
is
si
on
s
RLT, q = 24, M = 12
RLT, q = 24, M = 16
RLT, q = 24, M = 20
RLT, q = 24, M = 24
OBATS, q = 28, M = 12
OBATS, q = 28, M = 16 
OBATS, q = 28, M = 20   
OBATS, q = 28, M = 24
Fig. 6: The total number of transmissions per batch vs the number of hops under different batch
size.
VI. CONCLUSION
In this work, we conducted an optimization framework for evaluating the lower bound on the
number of packets from the source node to the sink node over multi-hop wireless networks. The
framework relied on the relation between the number of transmissions and the rank distribution of
the received batches, and was represented as an MINLP problem. By exploiting the properties of
the MINLP formulation, we developed the explicit expression for computing the rank distribution.
In addition, an NLP formulation was proposed as the upper bound on our problem, which was
also used as the performance measurement. Using these properties again, the global and local
real-time approaches are designed. Finally, we presented the numerical experiments to illustrate
the performance of the proposed approaches in terms of transmission efficiency and average
rank. The interesting question that remains open is how the algorithm described in this paper
can be extended to multicast networks.
REFERENCES
[1] Z. Fu, H. Luo, P. Zerfos, S. Lu, L. Zhang, and M. Gerla, “The impact of multihop wireless channel on TCP performance,”
IEEE Transactions on Mobile Computing, 2005, 4(2), pp: 209-221.
[2] R. Ahlswede, N. Cai, S.-Y.R. Li, and R.W. Yeung, “Network information flow,” IEEE Transactions on Information Theory,
2000, 46(4), pp: 1204-1206.
September 5, 2017 DRAFT
26
[3] S.-Y.R. Li, R.W. Yeung, and Ning Cai, “Linear network coding,” IEEE Transactions on Information Theory, 2003, 49(2),
pp: 371-381.
[4] K. Chi, X. Jiang, and S. Horiguchi, “Joint Design of Network Coding and Transmission Rate Selection for Multihop
Wireless Networks,” IEEE Transactions on Vehicular Technology, 2010, 59(5), pp: 2435-2444.
[5] A. Shokrollahi, “Raptor codes,” IEEE Transactions on Information Theory, 2006, 52(6), pp: 2551-2567.
[6] M. Luby, A. Shokrollahi, M. Watson, T. Stockhammer, and L. Minder, RaptorQ Forward Error Correction Scheme for Object
Delivery, Internet Engineering Task Force (IETF), TS RFC6330, 2011. [Online]: Available: http//:tools.ietf.org/html/rfc6330
[7] S. Yang, and R. Yeung, “Batched sparse codes,” IEEE Transactions on Information Theory, 60(9), 2014, pp. 5322-5346.
[8] S. Yang, R. W. Yeung, J. H.F. Cheung, and H. H.F. Yin, “BATS: Network Coding in Action”, in Proc. 2014 52nd Annual
Allerton Conference on in Communication, Control, and Computing (Allerton), Illinois, USA, Oct. 2014, pp: 1204-1211
[9] S. Yang, and Q. Zhou, “Tree Analysis of BATS Codes,” IEEE Communications Letters, 2016, 20(1), pp: 37-40.
[10] B. Tang, S. Yang, Y. Yin, B. Ye, and S. Lu, “Expander Graph Based Overlapped Chunked Codes”, in Proc. 2012 IEEE
International Symposium on Information Theory Proceedings (ISIT), Cambridge, MA, USA, July 2012, pp: 2451-2455.
[11] B. Tang, S. Yang, B. Ye, S. Guo, and S. Lu, “Near-Optimal One-Sided Scheduling for Coded Segmented Network Coding,”
IEEE Transactions on Computers, 2016, 65(3), pp: 929-939.
[12] K. Mahdaviani, M. Ardakani, H. Bagheri, and C. Tellambura, “Gamma Codes: A Low-Overhead Linear-Complexity
Network Coding Solution”, in Proc. International Symposium on Network Coding (NetCod), 2012 International Symposium
on, June 2012, pp: 125-130.
[13] T. C. Ng and S. Yang, “Finite-Length Analysis of Bats Codes,” in Proc. Int. Symp. Netw. Coding (NetCod), Calgary, AB,
Canada, Jun. 2013, pp. 1-6.
[14] Q. Huang, K. Sun, X. Li and D. Wu, “Just FUN: A Joint Fountain Coding and Network Coding Approach to Loss-Tolerant
Information Spreading,” in Proc. The 15th ACM International Symposium on Mobile Ad Hoc Networking and Computing,
Philadelphia USA, August 2014, pp: 83-92.
[15] H. Zhang, K. Sun, Q. Huang, Y. Wen, and D. Wu, “FUN Coding: Design and Analysis,” IEEE/ACM Transactions on
Networking, 2016, 24(6), pp: 3340-3353.
[16] X. Xu, M. S.G.P. Kumar, Y.-L. Guan, and P. H.J. Chong, “Two-Phase Cooperative Broadcasting Based on Batched Network
Code,” IEEE Transactions on Communications, 2016, 64(2), pp: 706-714.
[17] H.F. Yin, S. Yang, Q. Zhou, and L. M.L. Yung, “Adaptive Recoding for BATS Codes,” in Proc. 2016 IEEE International
Symposium on Information Theory (ISIT), Barcelona, Spain, July 2016, pp: .
[18] S.D. Muruganathan, D.C.F. Ma, R.I. Bhasin, and A.O. Fapojuwo, “A Centralized Energy-Efficient Routing Protocol for
Wireless Sensor Networks,” IEEE Communications Magazine, 2005, 43(3), pp: S8-13.
[19] Y. Li, Y. Jiang, D. Jin, L. Su, L. Zeng, and D. Wu, “Energy-Efficient Optimal Opportunistic Forwarding for Delay-Tolerant
Networks,” IEEE Transactions on Vehicular Technology, 2010,59(9), pp: 4500-4512.
[20] J. Fulman, and L. Goldstein, “Steins Method and the Rank Distribution of Random Matrices over Finite Fields,” The
Annals of Probability, 2015, 43(3), pp: 1274-1314.
[21] M. Zelen and N. C. Severo, “Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables,” M.
Abramowitz and I. A. Stegun, Eds. New York: Dover, 1972.
[22] R. Bassoli, V. N. Talooki, H. Marques, J. Rodriguez, R. Tafazolli, and S. Mumtaz, “Hybrid Serial Concatenated Network
Codes for Burst Erasure Channels,” in Proc. 2015 IEEE 81st Vehicular Technology Conference (VTC Spring), Glasgow,
UK, May 2015, pp: 1-4.
[23] H. Zhao, G. Dong, and H. Li, “Simplified BATS Codes for Deep Space Multihop Networks,” in Proc. IEEE Information
Technology, Networking, Electronic and Automation Control Conference, Chongqing, China, May 2016, pp: 311-314.
September 5, 2017 DRAFT
27
[24] R. J. La, and V. Anantharam, “Utility-Based Rate Control in the Internet for Elastic Traffic,” IEEE Transactions on
Networking, 2002, 10(2), pp: 272-286.
[25] C. E. Perkins, and P. Bhagwat, “Highly Dynamic Destination Sequenced Distance-Vector Routing (DSDV) for Mobile
Computers,” in Proc. Conf. Commun. Archit., Protocols Appl., 1994, pp. 234244.
[26] P. Belotti, J. Lee, L. Liberti, F. Margot, and A. Wchter, “Branching and Bounds Tightening Techniques for Non-Convex
MINLP,” Optimization Methods and Software, 2009, 24, pp: 597634.
[27] S. Le Digabel, “Algorithm 909: NOMAD: Nonlinear Optimization with the Mads Algorithm,” ACM Transactions on
Mathematical Software, 2011, 37(4), PP: 115.
[28] V. B. Gantovnik, Z. Gurdal, L. T. Watson, and C. M. Anderson-Cook, “Genetic Algorithm for Mixed Integer Nonlinear
Programming Problems using Separate Constraint Approximations,” (AIAA journal,) 2005, 43(8), pp. 18441849.
[29] KNITRO solver, https://www.artelys.com/en/optimization-tools/knitro.
APPENDIX A
PROOF OF THOEREM 1
For the rank of a totally random matrix, we have the following lemma.
Lemma A.1: The probability that the rank of a totally random matrix M ? Fn×mq , denoted
by rk(M), is r ? min(s, t) is given by [20]
Pr{rk(M) = r} = 1
q(n?r)(m?r)
r?1?
k=0
(1? q?n+k)(1? q?m+k)
(1? q?r+k)
(26)
= ?n,mr . (27)
Another lemma that will be useful is as follows.
Lemma A.2: Consider an invertible matrix M ? Fn×nq and a random vector v ? Fnq with
uniform, independent entries. Let w = Mv. Then, vector w is uniformly distributed over Fnq .
Proof: As M is invertible, we can write M = I·
?k
i=1 Ei, k ? 1, where I is an identity matrix
and Ei are elementary matrices. First, we claim that w? = Eiv is uniformly distributed over Fnq .
When matrix Ei corresponds to switching or multiplication operation, the claim is clearly true.
Next, let us consider Ei with an element, called m ? Fq, in the (i, j) position. Without loss of
generality, let i = 1, j = 2, and v = [v1, v2, · · · , vn]. Thus, w? = Eiv = [v1 +mv2, v2, · · · , vn].
According to the assumption, v2, . . . , vn are i.i.d. Then, let random variable v? = v1 + mv2. We
have
Pr(v? = x) =
?
i?Fq
Pr(v2 = i) Pr(v1 = x?mi) =
1
q
, x ? Fq.
September 5, 2017 DRAFT
28
That is, v? follows uniform distribution. Also, we write
Pr(v? = x, v2 = y) = Pr(v? = x|v2 = y) Pr(v2 = y)
= Pr(v1 = x?my) Pr(v2 = y)
=
1
q2
= Pr(v? = x) Pr(v2 = y), x, y ? Fq.
That is, v? is independent of v2. Therefore, it implies that w? is uniformly distributed over Fnq .
Finally, since w? = Iw?, the proof is completed.
With the above lemmas, we then get
Lemma A.3: Let A ? Fs×tq be a random matrix with arbitrary probability distribution, and let
B ? Ft×mq be a totally random matrix. The probability that the rank of matrix AB, conditional
on rk(A) = n, is r ? min(n,m, t) is given by
Pr{rk(AB) = r|rk(A) = n} = ?n,mr . (28)
Proof: Applying the elementary row and column operation to A, we get
A = L
??IA 0
0 0
??U,
where L and U are invertible matrices, and IA is a rk(A)× rk(A) identity matrix. We write
Pr {rk(AB) | rk(A)}
= Pr
???rk
??L
??IA 0
0 0
??UB
???????? rk(IA)
???
= Pr
???rk
????IA 0
0 0
??UB
???????? rk(IA)
???
= Pr {rk(C)} ,
where C is an n×m matrix obtained by keeping the first i rows of UB. According to Lemma
A.2, UB is a totally random matrix, so is C. Then, the proof is directly completed by Lemma
A.1.
September 5, 2017 DRAFT
29
In this paper, the transfer matrix can be fully described as follows. With slight abuse of
notation, we use Hk to represent the transfer matrix obtained by node vk, k ? 15. Define ?k
as the tk?1 × tk totally random matrix generated by node vk. In particular, t0 = M . Define Dk
as a tk × tk random diagonal matrix consisting of independent diagonal entries djj = 1 with
probability 1 ? k and djj = 0 with probability k, j = 1, 2, . . . , tk. The transfer matrix Hk+1
can, then, be expressed as,
Hk+1 = Hk?kDk, k = 1, . . . , l, (29)
where H1 = diag(1, 1, . . . , 1) is an M×M identity matrix. That is, the rank of Hk (1 ? k ? l) is
no more than M . In addition, we postulate that ?1, . . . ,?l,D1, . . . ,Dl are mutually independent.
Proof of Theorem 1: Let index set ?k = {i : dk,i 6= 0, i = 1, 2, . . . , tk}, where dk,i denotes
the i-th column of Dk. Using Eq. (29), we have
hk+1,r = Pr{rk(Hk+1) = r} = Pr{rk(Hk?kDk) = r}
=
M?
m=r
tk?
n=r
Pr{rk(Hk?kDk) = r, rk(Hk) = m, |?k| = n}
=
M?
m=r
tk?
n=r
Pr{rk(Hk) = m}Pr{|?k| = n}Pr{rk(Hk?kDk) = r | rk(Hk) = m, |?k| = n},
(30)
where Pr{rk(Hk) = m} = hk,m, and the probability of the cardinality of set ?k follows a
binomial distribution, i.e., Pr{|?k| = n} =
(
tk
n
)
(1? k)n tk?nk . Moreover, the cardinality of set
?k implies that ?kDk ? Ftk?1×|?k|q . Consequently, the proof is completed by applying Lemma
A.3.
APPENDIX B
PROOF OF LEMMA 1
Proof of Lemma 1: Since matrix Pk is a lower-triangular matrix, its diagonal components
are the eigenvalues. Let Q = [q1,q2, . . . ,qM+1]. To complete the proof, we need to exam the
following equality
(Pk ? ?k,jI)qj = 0. (31)
5Let Hk,i be the transfer matrix corresponding to the i-th batch received by node vk, k ? 1. Here, we ignore the subscript
i, because each batch is independently encoded and retransmitted such that the matrices Hk,i obtained by node vk are i.i.d.
September 5, 2017 DRAFT
30
(0)
= f(k, j ? 1)?j?1,j?1j?1 ?
m
j?1+f(k, j)?
j?1,j
j?1 ?
m
j?1+· · ·+f(k,m? 1)?j?1,m?1j?1 ?
m
j?1+
tk?
n=m
f(k, n)?j?1,nj?1 ?
m
j?1,
(1)
= f(k, j ? 1)?m,j?1j?1 ?
j?1
j?1 + f(k, j)?
m,j
j?1?
j?1
j?1 +· · ·+ f(k,m? 1)?
m,m?1
j?1 ?
j?1
j?1 +
tk?
n=m
f(k, n)?m,nj?1 ?
j?1
j?1 ,
(2)
= 0 + f(k, j)?m,jj ?
j
j?1 +· · ·+ f(k,m? 1)?
m,m?1
j ?
j
j?1 +
tk?
n=m
f(k, n)?m,nj ?
j
j?1,
...
...
...
(m? j + 1)
= 0 + 0 +· · ·+f(k,m? 1)?m,m?1m?1 ?
m?1
j?1 +
tk?
n=m
f(k, n)?m,nm?1?
m?1
j?1 ,
(m? j + 2)
= 0 + 0 +· · ·+ 0 +
tk?
n=m
f(k, n)?m,nm ?
m
j?1.
(34)
Case 1: j = 1.
As Pk is a translation matrix, we have
?k,1 = 1 =
M+1?
i=1
tk?
n=i?1
f(k, n)?m?1,ni?1 . (32)
Substituting (32) into (31), it is clear that the claim holds for j = 1.
Case 2: j = 2, 3, . . . ,M + 1.
Let us consider ?k,j and the (m+ 1)-th component ?m+1 of vecter (Pk ? ?k,jI)qj , where
?m+1 =
tk?
n=j?1
f(k, n)?m,nj?1 ?
j?1
j?1? ?? ?
(1)
+
tk?
n=j
f(k, n)?m,nj ?
j
j?1? ?? ?
(2)
+ · · ·
+
tk?
n=m?1
f(k, n)?m,nm?1?
m?1
j?1? ?? ?
(m?j+1)
+
tk?
n=m
f(k, n)?m,nm ?
m
j?1? ?? ?
(m?j+2)
?
tk?
n=j?1
f(k, n)?j?1,nj?1 ?
m
j?1? ?? ?
(0)
, 3 ? j ?M + 1, j ? m ?M + 1. (33)
In particular, ?m+1 = 0, m < j. We expand each component of Eq. (33) into Eq. (34).
September 5, 2017 DRAFT
31
Replacing (34) back into (33), we get
?m+1 =f(k, j ? 1)
(
?m,j?1j?1 ?
j?1
j?1 ? ?
j?1,j?1
j?1 ?
m
j?1
)
+ f(k, j)
(
1?
k=0
?m,jj?1+k?
j?1+k
j?1 ? ?
j?1,j
j?1 ?
m
j?1
)
+ · · ·+ f(k,m? 1)
(
m?j?
k=0
?m,m?1j?1+k ?
j?1+k
j?1 ? ?
j?1,m?1
j?1 ?
m
j?1
)
+
tk?
n=m
f(k, n)
(
m?j+1?
k=0
?m,nj?1+k?
j?1+k
j?1 ? ?
j?1,n
j?1 ?
m
j?1
)
? ?? ?
(a)
. (35)
Next, we rewrite equation (a) to
m?j+1?
k=0
?m,nj?1+k?
j?1+k
j?1 ? ?
j?1,n
j?1 ?
m
j?1
=
m?j+1?
k=0
?mj?1+k?
n
j?1+k?
j?1+k
j?1
?j?1+kj?1+k q
(m?j+1?k)(n?j+1?k)
?
?j?1j?1?
n
j?1?
m
j?1
?j?1j?1
(b)
= ?mj?1?
n
j?1
(
m?j+1?
k=0
?m?j+1k ?
n?j+1
k
?kk q
[(m?j+1)?k][(n?j+1)?k] ? 1
)
= ?mj?1?
n
j?1
(
m?j+1?
k=0
?m?j+1,n?j+1k ? 1
)
, (36)
where (b) follows the fact that
?mj?1+k =
j+k?2?
r=0
(1? q?m+r)
=
j?2?
x=0
(1? q?m+x)
k?1?
y=0
(1? q?(m?j+1)+y)
= ?mj?1?
m?j+1
k ,
September 5, 2017 DRAFT
32
Applying (36) to (35), we get
?m+1 =f(k, j ? 1)?mj?1?
j?1
j?1 (1? 1) + f(k, j)?mj?1?
j
j?1
(
1?
k=0
?m?j+1,1k ? 1
)
+ · · ·+ f(k,m? 1)?mj?1?m?1j?1
(
m?j?
k=0
?m?j+1,m?jk ? 1
)
+
tk?
n=m
f(k, n)?mj?1?
n
j?1
(
m?j+1?
k=0
?m?j+1,n?j+1k ? 1
)
(c)
=f(k, j ? 1)?mj?1?
j?1
j?1 × 0 + f(k, j)?mj?1?
j
j?1 × 0 + · · ·
+ f(k,m? 1)?mj?1?m?1j?1 × 0 +
tk?
n=m
f(k, n)?mj?1?
n
j?1 × 0
=0,
where (c) is derived from Lemma A.1,
m?j+1?
k=0
?m?j+1,n?j+1k =
m?j+1?
k=0
Pr
{
rk(M) = k |M ? F(m?j+1)×(n?j+1)q
}
= 1, j ? m ? n.
The proof is completed.
APPENDIX C
PROOF OF THEOREM 4
In order to prove Theorem 4, we need the following lemmas.
Lemma C.1: Let ? ? Fm×nq and ?? ? Fm×nq? are totally random matrices. If q < q?, then
Pr{rk(?) ? r} ? Pr{rk(??) ? r}, 0 ? r ? min(m, n). The equality holds if and only if r = 0.
Proof: Without loss of generality, we assume n ? m. Then, the theorem is proved by
induction on n. For n = 1, 2, it can be verified by the following facts,
Pr{rk(?) = 0} = q?mn > q??mn = Pr{rk(??) = 0},
Pr{rk(?) = n} =
n?1?
i=0
(1? q?m+i) <
n?1?
i=0
(1? q??m+i)
= Pr{rk(??) = n}.
September 5, 2017 DRAFT
33
Suppose the claim holds for n = l ? 1. Then, let us consider n = l. In particular, we define
the m× l matrices as ?l = [a1, . . . , al] and ??l = [a?1, . . . , a?l], and let ??l? be the column space
of ?l. We have
Pr{rk(?l) ? r} = Pr{rk(?l?1) ? r}+ Pr{rk(?l?1) = r ? 1, al /? ??l?1?}
= Pr{rk(?l?1) ? r}+ (1? q?m+r?1) Pr{rk(?l?1) = r ? 1}, (37)
Pr{rk(??l) ? r} = Pr{rk(??l?1) ? r}+ (1? q??m+r?1) Pr{rk(??l?1) = r ? 1}, r > 0 (38)
where ?l?1 = [a1, . . . , al?1] and ??l?1 = [a?1, . . . , a?l?1] are submatrices of ?l and ??l, respec-
tively. To compare Eq. (37) and (38), there are two cases:
Case 1: Pr{rk(?l?1) = r ? 1} < Pr{rk(??l?1) = r ? 1}. With the assumption and (1 ?
q?m+r?1) < (1? q??m+r?1), we get Pr{rk(?l) ? r} < Pr{rk(??l) ? r}.
Case 2: Pr{rk(?l?1) = r ? 1} ? Pr{rk(??l?1) = r ? 1}. We rewrite Eq. (37) and (38) into
Pr{rk(?l) ? r} = Pr{rk(?l?1) ? r ? 1} ? q?m+r?1 Pr{rk(?l?1) = r ? 1},
Pr{rk(??l) ? r} = Pr{rk(??l?1) ? r ? 1} ? q??m+r?1 Pr{rk(??l?1) = r ? 1}.
With the assumption and q?m+r?1 > q??m+r?1, we obtain Pr{rk(?l) ? r} < Pr{rk(??l) ? r}.
In particular, Pr{rk(?l) ? 0} = Pr{rk(??l) ? 0} = 1. Consequently, the proof is completed
by induction.
Lemma C.2: If ? ? Fm×nq and ?? ? Fm×n?q , n < n?, are totally random matrices, then
Pr{rk(?) ? r} ? Pr{rk(??) ? r}, 0 ? r ? min(m, n?). The equality holds if and only if
r = 0.
The proof is similar to that of Lemma C.1 and thus is omitted.
Lemma C.3: The average rank increases with finite field size q with given tk, k = 1, . . . , l.
Proof: Suppose q < q?, and the elements of totally random matrices ?k and ??k, 1 ? k ? l,
are chosen from Fq and Fq?, respectively. We claim that Pr{rk(Hk+1 = Hk?kDk) ? r} <
Pr{rk(H?k+1 = H?k??kDk) ? r}, r > 0. This can be proved by induction on k, the number of
hops. For k = 1, we have
Pr{rk(H2 = H1?1D1) ? r} = Pr{rk(?1D1) ? r}
(a)
< Pr{rk(H?2 = H1??1D1) ? r} = Pr{rk(??1D1) ? r}, r > 0.
where (a) follows by Lemma C.1, as ?1D1 and ??1D1 belong to the subspaces with the same
dimension.
September 5, 2017 DRAFT
34
Next, suppose that the claim holds for k = l? 1. Then, let us consider k = l, and let random
matrix H?l ? FM×tkq? have the same rank distribution as Hl, i.e. Pr{rk(H?l) ? r} = Pr{rk(Hl) ?
r}, r > 0. We write
Pr{rk(H?l+1 = H?l??lDl) ? r} =
M?
x=r
Pr{rk(H?l??lDl) = x}
=
M?
x=r
M?
m=x
Pr{rk(H?l) = m}g(m,x, l, q?)
=
M?
m=r
h?l,m
(
m?
x=r
g(m,x, l, q?)
)
(b)
>
M?
m=r
h?l,m
(
m?
x=r
g(m,x, l, q?)
)
(c)
>
M?
m=r
hl,m
(
m?
x=r
g(m,x, l, q)
)
= Pr{rk(Hl+1 = Hl?lDl) ? r}, r > 0.
where g(m,x, l, q?) =
?M
n=x f(l, n)?
m,n
x , (b) follows Lemma C.2, i.e.,
m?
x=r
g(m,x, l, qi) >
m?y?
x=r
g(m,x, l, qi),
r > 0, m > y > 0, qi = q, q?
and (c) is due to the assumption and Lemma C.1, i.e.,
m?
x=r
g(m,x, l, q?) >
m?
x=r
g(m,x, l, q),
Therefore, the claim is proved by induction. With this claim, we then obtain
~k+1 =
M?
j=0
jhk+1,j =
M?
j=1
Pr{Hk+1 ? j}
<
M?
j=1
Pr{H?k+1 ? j} = ~?k+1.
The proof is completed.
Proof of Theorem 4: It is a direct consequence of Lemma C.3 and the fact that the
continuous relaxation of ti, i = 1, . . . , l, gives an extended feasible region containing the feasible
region of P1.
September 5, 2017 DRAFT
35
APPENDIX D
PROOF OF PROPOSITION 2
Lemma D.1: Let ? ? Fm×tq and ?? ? Fm×t?q be totally random matrices, and let D and D?
be t× t and t?× t? random diagonal matrices, respectively. If t < t?, then Pr{rk(H?D) ? r} ?
Pr{rk(H???D?) ? r}, 0 ? r ? k ? min(M,m, t), where H and H? are arbitrary M×m matrices,
and Pr{rk(H) ? r} ? Pr{rk(H?) ? r}. The equality holds if and only if r = 0
Proof: Let ??t be a matrix consisting of arbitrary t columns of ??, and let X be the event
that there are at least x columns of ?? not belonging to space ???t?. We have
Pr{rk(??) ? r} = Pr{rk(??t) ? r}
+
min(t??t,r)?
i=1
Pr{rk(??t) = r ? i,X = i}
Since ??t is a m× t totally random matrix, we obtain
Pr{rk(??) ? r} ? Pr{rk(??t) ? r} = Pr{rk(?) ? r},
and then
Pr{rk(H???) ? r} ? Pr{rk(H??) ? r} ? Pr{rk(H?) ? r}.
Moreover, construct an M × t? matrix A = [H? 0], where 0 is an M × (t?? t) zero matrix.
Since Pr{rk(H?) ? r} = Pr{rk(A) ? r} ? Pr{rk(??) ? r} , we get
Pr{rk(H??D?) ? r} ? Pr{rk(AD?) ? r}
= Pr{rk(H?D) ? r}.
The proof is completed.
Proof of Proposition 2: Since t?1 is optimal, we have?M
r=1 ?r?rg(r, t
?
1)
l1
t?1
?
?M
r=1 ?r?rg(r, t)
l1
t
.
It can be verified that g(r, t), r = 1, . . . ,M , are monotonically increasing functions of t by
Lemma D.1. Consequently, for any t ? t?1, we obtain?M
r=1 ?r?rg(r, t
?
1)
l2
t?1
?
?M
r=1 ?r?rg(r, t)
l2
t
. (39)
Equation (39) shows that t?2 cannot be less than t
?
1.
September 5, 2017 DRAFT
