1
Wyner-Ziv Coding for Physical Unclonable
Functions and Biometric Secrecy Systems
Onur Gu?nlu?, Student Member, IEEE, Onurcan I?s?can, Vladimir Sidorenko, Member, IEEE, and Gerhard
Kramer, Fellow, IEEE
Abstract—Two constructive linear coding methods, previously
proposed for the Wyner-Ziv problem, are developed to achieve all
points of the key-leakage-storage regions of the generated- and
chosen-secret models of biometric secrecy systems. The models
also apply to physical unclonable functions that are realized by
fine hardware variations. The linear coding is implemented by
using nested polar codes and the designs achieve privacy-leakage
and storage rates that improve on existing methods.
Index Terms—Information theoretic privacy, secret key agree-
ment, physical unclonable functions, Wyner-Ziv coding.
I. INTRODUCTION
Biometric features like fingerprints are unique and can be
used to authenticate and identify individuals, and to generate
secret keys. Similarly, one can generate secret keys with
physical unclonable functions (PUFs) that are used as sources
of randomness. For example, fine variations of ring oscillator
outputs and the start-up behavior of static random access
memories (SRAM) can serve as PUFs [1]. Fingerprints and
PUFs are identifiers with high entropy and reliable outputs
[2], [3], and one can consider them as physical “one-way
functions” that are easy to compute and difficult to invert [4].
Various applications use the keys generated from biometric
or physical identifier outputs. For instance, a fifth generation
(5G) mobile device can use its SRAMs as a source to extract
secret keys to encrypt data. Similarly, digital internet-of-things
(IoT) devices that carry sensitive data, e.g., wearable or e-
health devices, can use a physical identifier to store secret
keys [5] so that only a mobile device with access to this
secret key can control the IoT device. This application provides
low-complexity data privacy; see, for instance, [6] for other
applications of PUFs in 5G wireless networks.
PUFs provide security against invasive attacks since their
outputs permanently change if an attacker tampers with the
device [3]. Physical-layer security solutions proposed for wire-
less networks do not generally provide security against such
attacks. Therefore, hardware-intrinsic security for 5G wireless
The work of O. Gu?nlu? was supported by the German Research Foundation
(DFG) through the project HoliPUF under the grant KR3517/6-1. V. Sidorenko
is on leave from the Institute for Information Transmission Problems, Russian
Academy of Science. The work of G. Kramer was supported by an Alexander
von Humboldt Professorship endowed by the German Federal Ministry of
Education and Research.
O. Gu?nlu?, V. Sidorenko, and G. Kramer are with the Institute for Com-
munications Engineering, Technical University of Munich, Munich, Germany
(e-mail: {onur.gunlu, vladimir.sidorenko, gerhard.kramer}@tum.de).
O. I?s?can is with the Huawei European Research Center, Munich, Germany
(email: onurcan.iscan@huawei.com).
networks provides a low-complexity security and privacy solu-
tion that is complementary to physical-layer security solutions.
Replacing biometric and physical identifiers is often expen-
sive, or not possible, and this means that the same identifier
is used many times. One should, therefore, find the limits for
the information leaked to an eavesdropper about the identifier
(privacy leakage) and about the secret key (secrecy leakage) as
well as the limits for the amount of storage. We consider two
models for leakage and storage analysis called the generated-
secret (GS) and the chosen-secret (CS) models.
A. Related Work
We briefly review the past work. The region of achievable
secret-key vs. privacy-leakage (key vs. leakage) rates for the
GS and CS models are given in [2] and [7]. The storage
rates for different secrecy-leakage rates and multiple encoder
measurements are analyzed, respectively, in [8] and [9]. The
binary Golay code is used in [2] as a vector quantizer in
combination with Slepian-Wolf (SW) coding techniques [10]
to illustrate that the key vs. leakage rate ratio can be increased
via quantization.
A polar code based construction is proposed in [5] for the
GS model. This construction assumes a “private” key shared
only by an encoder and a decoder, which is not realistic since
a private key requires hardware protection against invasive
attacks. If such a protection is possible, then there is no need
to use an on-demand key storage method like a PUF.
B. Motivation and Organization
The bounds on the storage rate of the GS model and on the
Wyner-Ziv (WZ) rate have the same expressions. We further
show that there is a code that satisfies the constraints of both
problems, corresponding to a functional equivalence of the
two problems. Extending this equivalence, we propose code
constructions that asymptotically achieve all points of the key-
leakage-storage region, and that improve on existing methods
in [5], [11], and [12]. We consider both key generation
(GS model) and embedding (CS model) problems to address
different practical scenarios.
This paper is organized as follows. In Sections II-A and
II-B, we describe the GS and CS models, the WZ problem,
and give their rate regions. In Section II-C, we prove that
there is a code that satisfies the constraints of the WZ problem
and the GS model simultaneously to motivate using WZ cod-
ing techniques for key generation and embedding problems.
Section III describes a constructive method and proves its
ar
X
iv
:1
70
9.
00
27
5v
1 
 [
cs
.I
T
] 
 1
 S
ep
 2
01
7
2
asymptotic optimality for the GS and CS models. We improve
existing methods, and we show their suboptimality even after
known improvements in Section IV. The gain is in the privacy-
leakage rates. We design nested polar codes in Section V. We
use the WZ code construction proposed in [13] to generate
secret keys from SRAM PUFs with a block-error probability
of at most 10?6 and a minimum secret-key size of 128 bits.
The proposed codes achieve operating points that cannot be
achieved by existing methods.
C. Notation
Upper case letters represent random variables and lower
case letters their realizations. A superscript denotes a string of
variables, e.g., Xn=X1 . . . Xi . . . Xn, and a subscript denotes
the position of a variable in a string. A random variable X
has probability distribution PX . Calligraphic letters such as X
denote sets, and set sizes are written as |X |. Bold letters such
as H represent matrices. T n (PX) denotes the set of length-n
letter-typical sequences with respect to the probability distri-
bution PX and the positive number  [14]. Enc(·) is an encoder
mapping and Dec(·) is a decoder mapping. X?Y ?Z indicates
a Markov chain. Hb(x) = ?x log x ? (1 ? x) log(1 ? x)
is the binary entropy function. The ?-operator is defined as
p ? x = p(1 ? x) + (1 ? p)x. The operator ? represents
the element-wise modulo-2 summation. A binary symmetric
channel (BSC) with crossover probability p is denoted by
BSC(p). Xn ? Bernn(?) denotes that Xn is an independent
and identically distributed (i.i.d.) binary sequence of random
variables with Pr[Xi = 1] = ? for i = 1, 2, . . . , n. The
superscript T represents the transpose.
II. PROBLEM FORMULATIONS
A. Generated- and Chosen-secret Models
Consider the GS model in Fig. 1(a), where a secret key is
generated from a biometric or physical source. The source X ,
measurement Y , secret key S, and storage W alphabets are
finite sets. During enrollment, the encoder observes an i.i.d.
sequence Xn, generated by the identifier (source) according to
some PX , and generates a secret key S and public helper data
W as (S,W )=Enc(Xn). During reconstruction, the decoder
observes a noisy source measurement Y n of Xn through a
memoryless channel PY |X together with the helper data W .
The decoder estimates the secret key as S?=Dec(Y n,W ). We
remark that we assume that an eavesdropper cannot observe
a sequence correlated with the identifier outputs because, for
many physical identifiers and some biometric identifiers, an
invasive attack that obtains a correlated sequence permanently
changes the identifier output.
Fig. 1(b) shows the CS model, where a secret key S? ? S
is embedded into the helper data as W ? = Enc(Xn, S?). The
decoder for the CS model estimates the secret key as S?? =
Dec(Y n,W ?).
Definition 1. A key-leakage-storage tuple (Rs, Rl, Rw) is
achievable for the GS or CS models if, given any ? > 0,
there is some n ? 1, an encoder, and a decoder such that
PX
(S,W )
(a)
= Enc (Xn)
W ?
(b)
= Enc(Xn, S?)
PY |X
S?
(a)
= Dec (Y n,W )
S??
(b)
= Dec (Y n,W ?)
(a)W
(b)W ?
Xn Y n
Enrollment Reconstruction
S S? S? S??
(a) (b)(a) (b)
Fig. 1. The (a) GS and (b) CS models.
Rs =
log |S|
n and
Pr[S? 6= S] ? ? (reliability) (1)
1
n
I(S;W ) ? ? (secrecy) (2)
1
n
H(S) ? Rs ? ? (uniformity) (3)
1
n
log
??W?? ? Rw + ? (storage) (4)
1
n
I(Xn;W ) ? Rl + ?. (privacy) (5)
The key-leakage-storage regions Rgs and Rcs for the GS
and CS models, respectively, are the closures of the sets of
achievable tuples for the corresponding models. ?
Theorem 1 (Ignatenko and Willems [2]). The key-leakage-
storage regions for the GS and CS models, respectively, are
Rgs=
?
PU|X
{
(Rs, Rl, Rw) : 0 ? Rs ? I(U ;Y ),
Rl ? I(U ;X)? I(U ;Y ),
Rw ? I(U ;X)? I(U ;Y ) for
PUXY =PU |XPXPY |X
}
, (6)
Rcs=
?
PU|X
{
(Rs, Rl, Rw) : 0 ? Rs ? I(U ;Y ),
Rl ? I(U ;X)? I(U ;Y ),
Rw ? I(U ;X) for
PUXY =PU |XPXPY |X
}
. (7)
The alphabet U of the auxiliary random variable U can be
limited to have size |U|?|X |+ 1 for both regions.
We give a sketch of the proof to motivate our code con-
struction in the next section.
Proof: Fix a PU |X . Randomly and independently gen-
erate codewords un(w, s), w = 1, 2, . . . , 2nRw , s =
1, 2, . . . , 2nRs according to
?n
i=1 PU (ui), where PU (ui) =?
x?X PU |X(u|x)PX(x). These codewords define the random
codebook
C? = {Un(w, s)}(2
nRw ,2nRs )
(w,s)=(1,1) . (8)
Let 0<?<. We first consider the GS model.
3
Encoding: Given xn, the encoder looks for a codeword that
is jointly typical with xn, i.e., (un(w, s), xn)?T n? (PUX). If
there is one or more such codeword, the encoder chooses one
of them and puts out (w, s). If there is no such codeword, set
w=s=1. The encoder publicly stores the label w.
Decoding: The decoder puts out s? if there is a unique key
label s? that satisfies the typicality check (un(w, s?), yn) ?
T n (PUY ); otherwise, it sets s?=1.
Using standard arguments, there is a code that sat-
isfies (1)-(5) if we consider large n and approximately
2n(I(U ;X)?I(U ;Y )) storage labels w and 2nI(U ;Y ) key labels s,
i.e., Rw?I(U ;X)?I(U ;Y ) and Rs ? I(U ;Y ). The converse
follows from standard properties of the entropy function.
We now consider the CS model where we embed a secret
key s?. We add a one-time pad step to the encoding for the
GS model and store the new helper data w? = (w, s ? s?).
The decoder of the GS model puts out the estimate s? so that
one can obtain the new key estimate for the CS model as
s?? = s? ? (s ? s?). Since the error probability Pr[S?? 6= S?] is
the same as the error probability Pr[S? 6= S] for the GS model,
we obtain the same secret-key and privacy-leakage rates. Due
to the additional helper data s ? s?, the storage rate is the
sum of the secret-key and storage rates of the GS model. The
converse follows from standard arguments.
B. Wyner-Ziv Problem
Consider two dependent random variables X and Y jointly
generated according to PXY . Fig. 2 depicts the WZ problem.
The source X , Y , and side information W alphabets are finite
sets. An encoder that observes Xn generates side information
W ? [1, 2nRw ]. The decoder observes Y n and W and puts out
a quantized version X?n of Xn. Define the average distortion
between Xn and the reconstructed sequence X?n as
1
n
n?
i=1
E[d(Xi, X?i(Y
n,W ))]
where d(x, x?) is a distortion function and x?(yn, w) is a
mapping. For simplicity, assume that d(x, x?) is bounded.
Definition 2. A WZ rate-distortion pair (Rw, D) is achievable
for a distortion measure d(x, x?) if, given any ? > 0, there is
some n ? 1, an encoder, and a decoder for which Rw =
log |W|
n and
1
n
n?
i=1
E[d(Xi, X?i(Y
n,W ))] ? D + ?. (9)
The WZ rate-distortion region RWZ is the closure of the set
of achievable rate-distortion pairs. ?
Theorem 2 (Wyner and Ziv [15]). The WZ rate-distortion
region is
RWZ=
?
PU|X
?
f(U,Y )
{
(Rw, D) :Rw ? I(U ;X)? I(U ;Y ),
D ? E[d(X, f(U, Y ))] for
PUXY =PU |XPXY
}
(10)
PXY X?n = Dec(Y n,W )
W = Enc(Xn)
Xn W
Y n
X?n
Fig. 2. The WZ problem.
where f(U, Y ) = X? is a reconstruction function used at the
decoder. One can limit the alphabet U of the auxiliary random
variable U to have size |U|?|X |+ 1.
We give a sketch of the proof that we use later.
Proof: Fix a PU |X and f(u, y) such that E[d(X, X?)] ?
D/(1+) for some distortion D and  > 0. Randomly and in-
dependently generate codewords un(w, s), w=1, 2, . . . , 2nRw ,
s = 1, 2, . . . , 2nRs according to
?n
i=1 PU (ui). We use the
same encoding and decoding steps as in the achievability
proof of the GS model. After finding a un(w, s?) that sat-
isfies (un(w, s?), yn) ? T n (PUY ), the WZ decoder puts out
f(ui, yi) = x?i for all i = 1, 2, . . . , n.
Using standard arguments, there is a code that satisfies (9) if
we consider large n and approximately 2n(I(U ;X)?I(U ;Y )) side
information (storage) labels w, i.e., Rw?I(U ;X)?I(U ;Y ).
We then have approximately 2nI(U ;Y ) s labels. The converse
follows from standard arguments.
C. Functional Equivalence
We first give an equivalence result.
Theorem 3. Consider the GS model with the probability
distributions PX and PY |X , and the WZ problem with the joint
probability distribution PXY = PXPY |X and a distortion
function d(x, x?). For every probability distribution PU |X and
reconstruction function f(·), and a distortion D that satisfies
the distortion constraint in (10), there is some n ? 1, an
encoder, and a decoder that satisfy (1)-(5) and (9) simultane-
ously.
Proof: Consider the GS model with an additional distor-
tion constraint as in (9). Fix some PU |X and f(u, y) such that
|U|?|X |+1 and E[d(X, X?)] ? D/(1+) for some distortion
D and  > 0. Use the code construction, encoder, and decoder
given in the achievability proof of Theorem 1 so that one,
asymptotically, achieves a key-leakage-storage (Rs, Rl, Rw)
tuple. Using the typical average lemma [16, Section 2.4], the
rate-distortion (Rw, D) pair can be achieved as well.
Based on Theorem 3, we consider the GS and WZ problems
as functionally equivalent. Note that functional duality (see,
e.g., [17]) is related to functional equivalence, but we do not
exchange the encoders and decoders, unlike for functional
duality. One can also show a functional duality of the GS
model and the Gelfand-Pinsker problem [18], which is shown
in [17] to be a functional dual of the WZ problem.
Motivated by Theorem 3 and using the WZ code construc-
tion proposed in [19] for linear codes, we show in the next
section that such a construction with an additional privacy
amplification step achieves the boundary points of the key-
4
leakage-storage regions of the GS and CS models for binary
sources measured through a BSC.
III. CODE CONSTRUCTION
Consider the lossy source coding method proposed in [19]
that achieves the WZ rate-distortion function by using linear
codes. We combine this approach with a privacy amplification
step to achieve the boundary points of Rgs and Rcs for the GS
and CS models, respectively, for a binary uniform identifier
source and a BSC PY |X with crossover probability pA. We
remark that there are algorithms to obtain almost i.i.d. uniform
outputs from correlated and biased outputs (see, e.g., [1],
[20]). Fig. 3(a) and Fig. 3(b) plot the WZ code constructions,
respectively, for the GS and CS models.
Code Construction: Define the full-rank parity-check matri-
ces H1, H2, and H as
H =
[
H1
H2
]
(11)
where H1 with dimensions m1×n defines a binary linear code
C1 and H2 with dimensions m2 × n defines another binary
linear code C2. The code C defined by H in (11) is thus a
subcode of C1. For some q ? [0, 0.5], impose the conditions
m1
n
= Hb(q) + ? (12)
m1 +m2
n
= Hb(q ? pA) + 2? (13)
for some ? > 0. First, apply vector quantization (VQ) to a
uniformly distributed identifier output Xn by using C1. We
then generate and store public helper data by using C2.
Enrollment: The VQ in Fig. 3 quantizes the source output
Xn into the closest codeword Xnq in C1 in Hamming metric.
Define the error sequence
Enq = X
n ?Xnq . (14)
In the GS model, we publicly store the side information
W = XnqH
T
2 . (15)
We then choose a deterministic function g(·) for privacy
amplification [21] to generate a secret key as S = g(Xnq )
such that
H(S) = H(Xnq )?H(XnqHT )
(a)
= (n?m1)?H(XnqHT ) (16)
where (a) follows from the linearity of the code C1 and
uniformity of Xn. Since Xnq is uniformly distributed, the
min-entropy and collision entropy are equal to the Shannon
entropy and one can use universal families of hash functions
or extractors for privacy amplification [21].
For the CS model shown in Fig. 3(b), we have access to an
embedded (chosen) secret key S? that is independent of other
random variables and such that |S| = |S ?|. We store the helper
data W ? = [W, S ? S?].
Reconstruction: The noisy identifier output observed during
reconstruction is Y n = Xn ? Zn, where Zn is independent
of Xn and Zn ? Bernn(pA). The error sequence Enq and
PX
Xnq = VQ (H1, X
n)
S =g(Xnq ), W = X
n
qH
T
2
W ?
(b)
= [W, S ? S?]
PY |X
X?nq =Y
n?f([0, W ]? Y nHT )
S? = g(X?nq )
S??
(b)
= S? ? (S ? S?)
(a)W
(b)W ?
Xn Y n
Enrollment Reconstruction
S S? S? S??
(a) (b)(a) (b)
Fig. 3. WZ constructions for the (a) GS and (b) CS models.
the noise sequence Zn are independent. Furthermore, Enq
asymptotically resembles an i.i.d. sequence ? Bernn(q) when
n ? ? [19], [22]. Therefore, when n ? ?, the sequence
Enq ? Zn, which asymptotically corresponds to the noise
sequence of the equivalent channel PY n|Xnq , is distributed
according to Bernn(q?pA). One can thus reconstruct Xnq with
high probability when n?? by using the syndrome decoder
f(·) of the code C as follows
X?nq = Y
n ? f([0, W ]? Y nHT )
(a)
= Y n ? f(XnqHT ? Y nHT )
(b)
= (Xnq ? Enq ? Zn)? f((Enq ? Zn)HT )
(c)
= (Xnq ? Enq ? Zn)? (Enq ? Zn)
= Xnq (17)
where (a) follows from (15) and because Xnq is a codeword of
C1, (b) follows from (14), and (c) follows with high probability
because, asymptotically, Enq ?Zn ? Bernn(q ?pA) so that the
syndrome decoder f(·) determines the noise sequence Enq ?Zn
in the equivalent channel PY n|Xnq with high probability.
The secret-key is reconstructed in the GS model as
S? = g(X?nq ) (18)
and in the CS model as
S?? = g(X?nq )? (S ? S?) (19)
both of which result in the same error probability.
A. Optimality of GS Model Rates
Recall that Xn ? Bernn( 12 ) and that the channel PY |X is
a BSC(pA), where pA ? [0, 0.5]. Using Mrs. Gerber’s lemma
[23], the key-leakage-storage region of the GS model for this
case is
Rgs=
?
q?[0,0.5]
{
(Rs, Rl, Rw) : 0 ? Rs ? 1?Hb(q ? pA),
Rl ? Hb(q ? pA)?Hb(q),
Rw ? Hb(q ? pA)?Hb(q)
}
. (20)
The storage rate of the WZ code construction above is
Rw =
log |W|
n
=
m2
n
= Hb(q ? pA)?Hb(q) + ? (21)
5
which follows from (12) and (13). Using (16), the secret-key
and privacy-leakage rates are
Rs =
H(S)
n
=
n?m1
n
? 1
n
H(XnqH
T ) (22)
Rl =
H(W )
n
=
1
n
H(XnqH
T ). (23)
Since the parity-check matrix H2 has full rank, the public
side information in (15) is uniformly distributed because Xnq
is uniformly distributed (see also [24, Appendix A]) due to the
uniformity of Xn and linearity of C1. With the assumptions
above, and using XnqH
T
1 = 0, we obtain
Rs =
n?m1
n
? m2
n
= 1?Hb(q ? pA)? 2? (24)
Rl =
m2
n
= Hb(q ? pA)?Hb(q) + ? (25)
Rw =
m2
n
= Hb(q ? pA)?Hb(q) + ?. (26)
One can choose a ? in (12) and (13) such that ? ? 0 when
n ? ?. Therefore, the boundary points of the key-leakage-
storage region Rgs are the union of (Rs, Rl, Rw) rate tuples
over all q ? [0, 0.5].
B. Optimality of CS Model Rates
The key-leakage-storage region of the CS model for a uni-
form binary source measured through a BSC(pA) is similarly
Rcs=
?
q?[0,0.5]
{
(Rs, Rl, Rw) : 0 ? Rs ? 1?Hb(q ? pA),
Rl ? Hb(q ? pA)?Hb(q),
Rw ? 1?Hb(q)
}
. (27)
The storage rate for this case is the sum of the storage and
secret-key rates of the GS model, i.e., we have
Rw =
n?m1
n
= 1?Hb(q)? ? (28)
which follows from (24) and (26). The secret-key and privacy-
leakage rates are the same as in the GS model, and we have
Rs =
n?m1 ?m2
n
= 1?Hb(q ? pA)? 2? (29)
Rl =
m2
n
= Hb(q ? pA)?Hb(q) + ?. (30)
The union of these rate tuples over all q ? [0, 0.5] includes all
boundary points of Rcs.
IV. COMPARISONS WITH EXISTING METHODS
There are several existing methods proposed for the CS
and GS models, but some methods leak information about the
secret key. We consider three methods that satisfy the secrecy
leakage constraint in (2): the fuzzy-commitment scheme [11]
for the CS model, the code-offset fuzzy extractors [12] for the
GS model, and the polar code construction given in [5] for
the GS model.
The fuzzy commitment scheme has enrollment and re-
construction steps. During enrollment, an encoder takes a
uniformly distributed secret key S? as input to generate a
codeword Cn. The codeword and the binary source output Xn
are summed modulo-2, and the sum is stored as helper data
W ?. During reconstruction, W ? and another binary sequence
Y n, correlated with Xn through a BSC(pA), are summed
modulo-2 and this sum is used by a decoder to estimate S?.
Similar steps are applied in the code-offset fuzzy extractors,
except that the secret key is a hashed version of Xn. The
fuzzy commitment scheme achieves the Pareto-optimal point
in the key-leakage region with the maximum secret-key rate
Rs = I(X;Y ); the privacy-leakage rate is Rl = H(X|Y )
[25]. Similarly, the code-offset fuzzy extractors achieve the
same boundary point in the key-leakage region. This is,
however, the only Pareto-optimal point that these methods
achieve.
We can improve both methods by adding a VQ step:
instead of Xn we use its quantized version Xnq during
enrollment. This asymptotically corresponds to summing the
original helper data and an independent random variable
Jn ? Bernn(q) such that W ?? = Xn ? Cn ? Jn is the
new helper data. The modified fuzzy commitment scheme and
code-offset fuzzy extractors can achieve all points of the key-
leakage region. However, the helper data length n is equal to
the length of Xn for both methods. The resulting storage rate
of 1 bits/symbol is not optimal.
The polar code construction in [5] without an additional
private key requires less storage than the fuzzy commitment
scheme and code-offset fuzzy extractors. However, this ap-
proach improves only the storage rate and cannot achieve all
points of the key-leakage-storage region. One can improve this
construction by adding a VQ before the polar encoder during
enrollment. However, the effects of quantization on the finite-
length code design are not easy to analyze due to the lack of
a nested structure in the code construction.
The existing methods cannot, therefore, achieve all points
of the key-leakage-storage region for a BSC, unlike the
construction in Section III. The construction uses a code C1
as a good source code to quantize a noiseless identifier output
and a subcode C of C1 to correct the errors in the noisy
identifier outputs. Using these nested codes, the same secret
key is obtained during enrollment and reconstruction with high
probability, and we can asymptotically achieve all boundary
points by taking a union of all achieved rate tuples in (24)-(26)
or (28)-(30) over all q ? [0, 0.5].
In previous works such as [26], only the secret-key rates
of the proposed codes are compared because the sum of the
secret-key and privacy-leakage rates is one. This constraint
means that increasing the key vs. leakage rate ratio is equiv-
alent to increasing the key rate. However, the privacy-leakage
rate should be infinite to achieve the maximum secret-key rate
[27], and our construction is more flexible than the existing
methods in terms of achievable rate tuples. We therefore use
the key vs. leakage rate ratio as a metric to control the privacy
leakage in our finite-length designs below.
V. PROPOSED POLAR CODES FOR KEY GENERATION
Consider the WZ code construction from [13], which is
based on nested polar codes and does not require privacy
6
amplification, unlike the code construction in Section III. We
give an example for a uniform source output and a BSC for
the GS model by using polar codes. Polar codes have low
encoding and decoding complexity, and it is straightforward
to create a nested structure with them.
When designing polar codes, we want to increase the key
vs. leakage rate ratio
Rs
Rl
=
n?m1
m2
? 1 (31)
which suggests using small m1 and m2. However, large m1
and m2 are needed to satisfy the block-error probability
constraint, which results in a tradeoff. Note also that for the
WZ construction applied to the GS model, the privacy-leakage
and storage rates are equal. We thus use the secret-key and
privacy-leakage rates for analysis.
A. Polar Codes
Polar codes rely on the channel polarization phenomenon,
where the physical channel is converted into virtual channels
by a polar transform. This transform converts an input se-
quence Un with frozen and unfrozen bits to a codeword of the
same length n. A polar decoder processes a noisy observation
of the codeword together with the frozen bits to estimate Un
[28].
Let C(n,F , G|F|) denote a polar code of length n, where F
is the set of indices of the frozen bits, or channels, and G|F| is
the sequence of values of the corresponding frozen bits. In the
following, we use the nested polar code construction proposed
in [13]. Similar to Section III, this construction achieves the
boundary points of the key-leakage-storage region of the GS
model for large n. Using an additional one-time pad step with
an embedded secret key, one can show optimality also for the
CS model.
B. Polar Code Construction for the GS Model
We use two polar codes C1(n,F1, V ) and C(n,F , V ) with
F = F1?Fw and V = [V,W ], where V has length m1 and W
has length m2. The indices in F1 represent frozen channels for
both codes and C has some additional frozen channels denoted
by Fw, i.e., the codes are nested.
The code C1 serves as a VQ with a desired distortion q, and
the code C serves as the error correcting code for a BSC(q ?
pA). The idea is to obtain W during enrollment and store it
as public helper data. For reconstruction, W is used by the
decoder to estimate the secret key S of length n?m1 ?m2.
Fig. 4 shows the block diagram of the proposed construction.
In the following, suppose V is the all-zero vector so that no
additional storage is necessary.
Enrollment: The uniform binary sequence Xn generated by
a PUF during enrollment is treated as the noisy observation
of a BSC(q). Xn is quantized by a polar decoder of C1. We
extract from the decoder output Un the bits at indices Fw and
store them as the helper data W . The bits at the indices i ?
{1, 2, . . . , n}\F are used as the secret key. Note that applying
a polar transform to Un generates Xnq , which is a distorted
version of Xn. The distortion between Xn and Xnq is modeled
PX Xn BSC(pA)
Y n
Polar
Decoder C1
Un
Helper Data
and Key
Extraction
S
W
Polar
Decoder C
U?n
Key
Extraction
S?
V [V,W ]
Polar
Transform
BSC(q ? pA)
Xnq
Enrollment Reconstruction
Fig. 4. Proposed polar code based construction for the GS model.
as a BSC(q) because the error sequence Enq = X
n ? Xnq
resembles an i.i.d. sequence ? Bernn(q) when n??, as in
Section III.
Reconstruction: During reconstruction, the polar decoder of
C observes the binary sequence Y n (a noisy measurement of
Xn through a BSC(pA) PY |X ). The frozen bits V = [V,W ]
at indices F are input to the polar decoder. The output U?n
of the polar decoder is the estimate of Un and contains the
estimate S? of the secret key at the unfrozen indices of C, i.e.,
i ? {1, 2, . . . , n} \ F .
Construction of C and C1: Since C ? C1 are nested codes,
they must be constructed jointly. In particular, F and F1
should be selected such that the reliability and security con-
straints are satisfied. For a given secret key size n?m1?m2,
block length n, crossover probability pA, and target block-
error probability PB = Pr[S 6= S?], we propose the following
procedure.
1) Construct a polar code of rate (n?m1?m2)/n and use
it as the code C, i.e., define the set of frozen indices F .
2) Evaluate the error correction performance of C with a de-
coder for a BSC over a range of crossover probabilities
to obtain the crossover probability pc, resulting in a tar-
get block-error probability of PB . Using pc = E[q]?pA,
we obtain the target distortion E[q] averaged over all
realizations of Xn.
3) Find an F1 ? F that results in an average distortion of
E[q] with a minimum possible amount of helper data.
Use F1 as the frozen set of C1.
Step 1 is a conventional polar code construction task and step
2 can be applied by Monte-Carlo simulations. For step 3,
we start with F ?1 = F and compute the resulting average
distortion E[q?] via Monte-Carlo simulations. If E[q?] is not
less than E[q], we remove elements from F ?1 according to
the reliabilities of the polarized bit channels and repeat the
procedure until we obtain the desired average distortion E[q].
7
0.2 0.25 0.3 0.35
10?6
10?4
10?2
(0.1819, 10?6)
Code 1
(0.2682, 10?6)
Code 2
pc
P
B
Fig. 5. Block error probability of C over a BSC(pc) with an SCL decoder
(list size 8) for codes 1 and 2 of length 1024 and 2048, respectively.
C. Proposed Codes for the GS Model
Consider, for instance, the GS model where S is used in
the advanced encryption standard (AES) with length 128, i.e.,
log |S| = n?m1?m2 = 128 bits. If we use PUFs in a field-
programmable gate array (FPGA) as the randomness source,
we must satisfy a block-error probability PB of at most 10?6
[29]. Consider a BSC PY |X with crossover probability pA =
0.15, which is a common value for SRAM PUFs. We design
nested polar codes for these parameters to illustrate that we
can achieve better key-leakage-storage rates than previously
proposed codes.
Code 1: Consider n = 1024 and recall that n ? m1 ?
m2 = 128, PB = 10?6, and pA = 0.15. Polar successive
cancellation list (SCL) decoders with list size 8 are used as
the VQ and channel decoder. We first design the code C of rate
128/1024 and evaluate its performance with the SCL decoder
for a BSC with a range of crossover probabilities, as shown
in Fig. 5. We observe a block-error probability of 10?6 at a
crossover probability of pc = 0.1819. Since pA = 0.15, this
corresponds to an average distortion of E[q] = 0.0456, i.e.,
E[q] ? pA = 0.1819.
Fig. 6 shows the average distortion E[q] with respect to
n ? m1 = n ? |F1|, obtained by Monte-Carlo simulations.
We observe from Fig. 6 that the target average distortion is
obtained at n?m1 = 778 bits. Thus, m2 = 650 bits of helper
data suffice to obtain a block-error probability of PB = 10?6
to reconstruct a n?m1 ?m2 = 128-bits secret key.
Remark 1. Observe that the parameter pc is less than pA =
0.15 when we apply the procedure in Section V-B to n = 512
with the same PB . Therefore, it is not possible to construct
a code with this procedure for n ? 512 since q ? pA is an
increasing function of q for any q ? [0, 0.5]. Such a code
construction for n = 512 might be possible if one improves
the decoder.
Code 2: Consider the same parameters as in code 1, except
n = 2048. We apply the same steps as above and plot the
performance of an SCL decoder for a BSC with a range of
crossover probabilities in Fig. 5. A crossover probability of
pc = 0.2682 is required to obtain a block-error probability of
10?6, which gives an average distortion of E[q] = 0.1689.
Fig. 6 shows the average distortion with respect to n ?m1.
600 700 800 900 1,000
0
0.05
0.1
0.15
0.2
(778, 0.0456)
Code 1
(739, 0.1689)
Code 2
n?m1
E[
q]
Fig. 6. Average distortion E[q] with respect to n?m1 with an SCL decoder
(list size 8) for codes 1 and 2 of length 1024 and 2048, respectively.
We achieve the target average distortion with n ?m1 = 739
bits so that helper data of length 611 is required to satisfy
PB = 10
?6 for a secret key of length 128 bits.
The error probability PB is here an average over all PUF
realizations, i.e., over all PUF devices with the same circuit
design. To satisfy this block-error probability for each PUF
realization, one could consider using the maximum distortion
instead of E[q] as a metric in step 3 above. This would increase
the amount of helper data. We can guarantee a block-error
probability of at most 10?6 for 99.99% of all realizations xn
of Xn by adding 32 bits to the helper data for code 1 and 33
bits for code 2. The numbers of extra helper data bits required
are small since the variance of the distortion q over all PUF
realizations is small. For comparisons, we use the helper data
sizes required to guarantee PB = 10?6 for 99.99% of all PUF
realizations.
D. Code Comparisons and Discussions
We achieve the key-leakage-storage rates
(0.1250, 0.6660, 0.6660) bits/symbol by code 1 and
(0.0625, 0.3145, 0.3145) bits/symbol by code 2. These
rates are significantly better than the best rate tuple
(0.1250, 0.8750, 0.8750) in [5] in the literature for the same
parameters without any private key requirement. Moreover,
we increase the key vs. leakage rate ratio from 0.1877 for
code 1 to 0.1988 for code 2 by using longer blocklengths,
which suggests to further increase the blocklength to obtain
better ratios.
Code 2 achieves a privacy-leakage rate that cannot be
achieved by the existing methods without applying time shar-
ing (see, e.g., [16, Sec. 4.4] for its definition). This is because
the privacy-leakage rate 0.3145 bits/symbol achieved by code
2 is significantly less than the minimum privacy-leakage rate
Rl = Hb(pA) = 0.6098 bits/symbol achieved by, e.g., the
method of [11] without time sharing between the all-zero point
and the point with the maximum secret-key rate and minimum
possible privacy-leakage rate.
Consider, for instance, again the operating point with the
maximum secret-key rate and minimum possible privacy-
leakage and storage rates. This point can be asymptotically
achieved by the fuzzy commitment scheme. However, the
8
sphere packing bound (also the best possible meta-converse
bound for the source and channel we use [30]) states that
the highest key vs. leakage rate ratio that can be achieved
at this operating point with pA = 0.15, n = 1024, and
PB = 10
?6 is Rs/Rl = 0.3750. Similarly, the ratio is
Rs/Rl = 0.4373 for n = 2048 with the same pA and PB .
These results indicate that there are still gaps between the
maximum finite-length key vs. leakage rate ratios and the
ratios 0.1877 and 0.1988 achieved, respectively, by codes 1
and 2 above. The implementation gaps can be reduced by
using larger list sizes at the decoder, which is not desired for
IoT applications where hardware complexity is limited. For
other applications, codes that satisfy PB ? 10?9 should be
designed, for which either laborious decoder simulations or
analytical block-error probability bounds seem to be required.
VI. CONCLUSION
There are codes, encoders, and decoders that asymptotically
achieve all points of the rate regions of the WZ and GS prob-
lems simultaneously. Extending the functional equivalence, we
applied two asymptotically optimal WZ code constructions to
the GS and CS models for binary sources measured through
a BSC. We designed finite-length nested polar codes that
achieve better rate tuples than existing methods, and one of
our codes achieves a rate tuple that cannot be achieved by
existing methods without time sharing. Gaps to the maximum
key vs. leakage rate ratios were illustrated. In future work, we
will design nested polar codes with a block-error probability
PB ? 10?9 by approximating the weight distributions of the
codes.
ACKNOWLEDGMENT
The authors thank Amin Gohari for his insightful comments
and Peihong Yuan for his help with polar codes.
REFERENCES
[1] O. Gu?nlu?, O. I?s?can, and G. Kramer, “Reliable secret key generation from
physical unclonable functions under varying environmental conditions,”
in IEEE Int. Workshop Inf. Forensics Security, Rome, Italy, Nov. 2015,
pp. 1–6.
[2] T. Ignatenko and F. M. J. Willems, “Biometric systems: Privacy and
secrecy aspects,” IEEE Trans. Inf. Forensics Security, vol. 4, no. 4, pp.
956–973, Dec. 2009.
[3] B. Gassend, “Physical random functions,” Master’s thesis, M.I.T., Cam-
bridge, MA, Jan. 2003.
[4] R. Pappu, “Physical one-way functions,” Ph.D. dissertation, M.I.T.,
Cambridge, MA, Oct. 2001.
[5] B. Chen, T. Ignatenko, F. M. Willems, R. Maes, E. van der Sluis, and
G. Selimis, “A robust SRAM-PUF key generation scheme based on polar
codes,” July 2017, [Online]. Available: arxiv.org/abs/1701.07320.
[6] M. A. Ferrag, L. Maglaras, A. Argyriou, D. Kosmanos, and H. Janicke,
“Security for 4G and 5G cellular networks: A survey of existing
authentication and privacy-preserving schemes,” Aug. 2017, [Online].
Available: arxiv.org/abs/1708.04027.
[7] L. Lai, S.-W. Ho, and H. V. Poor, “Privacy-security trade-offs in
biometric security systems - Part I: Single use case,” IEEE Trans. Inf.
Forensics Security, vol. 6, no. 1, pp. 122–139, Mar. 2011.
[8] M. Koide and H. Yamamoto, “Coding theorems for biometric systems,”
in IEEE Int. Symp. Inf. Theory, Austin, TX, June 2010, pp. 2647–2651.
[9] O. Gu?nlu? and G. Kramer, “Privacy, secrecy, and storage with noisy
identifiers,” Jan. 2016, [Online]. Available: arxiv.org/abs/1601.06756.
[10] D. Slepian and J. Wolf, “Noiseless coding of correlated information
sources,” IEEE Trans. Inf. Theory, vol. 19, no. 4, pp. 471–480, July
1973.
[11] A. Juels and M. Wattenberg, “A fuzzy commitment scheme,” in ACM
Conf. Comp. and Commun. Security, New York, NY, Nov. 1999, pp.
28–36.
[12] Y. Dodis, R. Ostrovsky, L. Reyzin, and A. Smith, “Fuzzy extractors:
How to generate strong keys from biometrics and other noisy data,”
SIAM J. Comput., vol. 38, no. 1, pp. 97–139, Jan. 2008.
[13] S. B. Korada and R. Urbanke, “Polar codes for Slepian-Wolf, Wyner-
Ziv, and Gelfand-Pinsker,” in IEEE Inf. Theory Workshop, Cairo, Egypt,
Jan. 2010, pp. 1–5.
[14] A. Orlitsky and J. R. Roche, “Coding for computing,” IEEE Trans. Inf.
Theory, vol. 47, no. 3, pp. 903–917, Mar. 2001.
[15] A. Wyner and J. Ziv, “The rate-distortion function for source coding
with side information at the decoder,” IEEE Trans. Inf. Theory, vol. 22,
no. 1, pp. 1–10, Jan. 1976.
[16] A. E. Gamal and Y.-H. Kim, Network Information Theory. Cambridge,
U.K.: Cambridge Uni. Press, 2011.
[17] S. S. Pradhan, J. Chou, and K. Ramchandran, “Duality between source
coding and channel coding and its extension to the side information
case,” IEEE Trans. Inf. Theory, vol. 49, no. 5, pp. 1181–1203, May
2003.
[18] S. I. Gel’fand and M. S. Pinsker, “Coding for channels with random
parameters,” Probl. Contr. Inf. Theory, vol. 9, no. 1, pp. 19–31, Jan.
1980.
[19] S. Shamai, S. Verdu?, and R. Zamir, “Systematic lossy source/channel
coding,” IEEE Trans. Inf. Theory, vol. 44, no. 2, pp. 564–579, Mar.
1998.
[20] J. Wayman, A. Jain, D. Maltoni, and D. M. (Eds), Biometric Systems:
Technology, Design and Performance Evaluation. London, U.K.:
Springer-Verlag, 2005.
[21] M. Bloch and J. Barros, Physical-layer Security. Cambridge, U.K.:
Cambridge Uni. Press, 2011.
[22] A. J. Viterbi and J. K. Omura, Principles of Digital Communication and
Coding. Mineola: NY: Dover Publications, 2013.
[23] A. D. Wyner and J. Ziv, “A theorem on the entropy of certain binary
sequences and applications: Part I,” IEEE Trans. Inf. Theory, vol. 19,
no. 6, pp. 769–772, Nov. 1973.
[24] Y. Wang, S. Rane, S. C. Draper, and P. Ishwar, “A theoretical analysis of
authentication, privacy, and reusability across secure biometric systems,”
IEEE Trans. Inf. Forensics Security, vol. 7, no. 6, pp. 1825–1840, July
2012.
[25] T. Ignatenko and F. M. J. Willems, “Information leakage in fuzzy
commitment schemes,” IEEE Trans. Inf. Forensics Security, vol. 5, no. 2,
pp. 337–348, Mar. 2010.
[26] R. Maes, A. V. Herrewege, and I. Verbauwhede, “PUFKY: A fully
functional PUF-based cryptographic key generator,” in Cryptographic
Hardware Embedded Sys. Berlin Heidelberg, Germany: Springer-
Verlag, Sep. 2012, pp. 302–319.
[27] T. Ignatenko and F. M. J. Willems, “Privacy-leakage codes for biometric
authentication systems,” in IEEE Int. Conf. Acoustics, Speech Signal
Process., May 2014, pp. 1601–1605.
[28] E. Arikan, “Channel polarization: A method for constructing capacity-
achieving codes for symmetric binary-input memoryless channels,” IEEE
Trans. Inf. Theory, vol. 55, no. 7, pp. 3051–3073, July 2009.
[29] C. Bo?sch, J. Guajardo, A.-R. Sadeghi, J. Shokrollahi, and P. Tuyls, “Ef-
ficient helper data key extractor on FPGAs,” Cryptographic Hardware
Embedded Syst., pp. 181–197, Aug. 2008.
[30] Y. Polyanskiy, H. V. Poor, and S. Verdu?, “Channel coding rate in the
finite blocklength regime,” IEEE Trans. Inf. Theory, vol. 56, no. 5, pp.
2307–2359, May 2010.
