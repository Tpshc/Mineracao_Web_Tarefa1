A Secure Approach for Caching Contents in
Wireless Ad Hoc Networks
Mohsen Karimzadeh Kiskani† and Hamid R. Sadjadpour†
Abstract—Caching aims to store data locally in some nodes
within the network to be able to retrieve the contents in shorter
time periods. However, caching in the network did not always
consider secure storage (due to the compromise between time
performance and security). In this paper, a novel decentralized se-
cure coded caching approach is proposed. In this solution, nodes
only transmit coded files to avoid eavesdropper wiretappings and
protect the user contents. In this technique random vectors are
used to combine the contents using XOR operation. We modeled
the proposed coded caching scheme by a Shannon cipher system
to show that coded caching achieves asymptotic perfect secrecy.
The proposed coded caching scheme significantly simplifies the
routing protocol in cached networks while it reduces overcaching
and achieves a higher throughput capacity compared to uncoded
caching in reactive routing. It is shown that with the proposed
coded caching scheme any content can be retrieved by selecting
a random path while achieving asymptotic optimum solution. We
have also studied the cache hit probability and shown that the
coded cache hit probability is significantly higher than uncoded
caching. A secure caching update algorithm is also presented.
Index Terms—Secure Caching, Physical Layer Security, Wire-
less Ad Hoc Networks
I. INTRODUCTION
Significant advances in wireless and mobile technologies
over the past decades, have made it possible for mobile users
to stream high quality videos and to download large-sized
contents. Video streaming applications like Netflix, Hulu and
Amazon have become increasingly popular among mobile
users. Close to half of all video plays were on mobile devices
like tablets and smartphones1 during the fourth quarter of
2015.
In parallel, storage capacity of mobile devices has signif-
icantly increased without being fully utilized. Efficient use
of this under-utilized storage is specially important for video
streaming applications that account for a large portion of the
overall internet traffic.
On the other hand, proprietary contents as opposed to user-
generated contents are the most important assets of many
content sharing companies such as Netflix, Hulu, and Amazon.
These companies use extreme measures to protect their data
and therefore, they are hesitant to let the end users cache
their contents locally. One possible solution is to encrypt
Copyright (c) 2015 IEEE. Personal use of this material is permitted.
However, permission to use this material for any other purposes must be
obtained from the IEEE by sending a request to pubs-permissions@ieee.org.
M. K. Kiskani† and H. R. Sadjadpour† are with the Department of
Electrical Engineering, University of California, Santa Cruz. Email: {mohsen,
hamid}@soe.ucsc.edu
1http://go.ooyala.com/rs/447-EQK-225/images/Ooyala-Global-Video-
Index-Q4-2015.pdf
each content before caching it locally. Encryption algorithms
reduce the content sharing rate. Further, such algorithms are
only computationally secure and an adversary is able to break
them with time. For instance, Data Encryption Standard (DES)
which was once the official Federal Information Processing
Standard (FIPS) in US is no longer considered secure. In this
paper, we propose an information theoretically secure solution
for caching contents which cannot be decoded with time.
Physical layer security in wireless networks has been the
subject of many recent research papers. With a focus on
physical layer security in wireless ad hoc networks, we pro-
pose a novel decentralized coded caching approach in which
random vectors are used to combine the contents using XOR
operation. Nodes only transmit coded files and therefore an
eavesdropper with a noiseless channel will not be able to
decode the desired contents. Our technique is quite different
from techniques which exploit wireless channel dynamics to
achieve physical layer security. We demonstrate that coded
caching technique is similar to Shannon cipher [24] problem
and it can achieve asymptotic perfect secrecy during file
transmissions by using a secure low bandwidth channel to
exchange the decoding gains. The main contributions of this
paper are introduction of decentralized coded caching for
wireless ad hoc networks, capacity computation of coded and
uncoded caching for proactive and reactive routing strategies2,
proof of security, computation of cache hit probability, and
introduction of update algorithm.
A shorter version of this paper was presented in [14] that
does not include proofs for Theorems 2 and 3 and Lemma 4.
The cache hit probability and cache update algorithm were
not addressed in [14]. The rest of the paper is organized
as follows. In section II, the related works are described.
In section III the network model, proposed encoding and
decoding algorithms and earlier results on coded caching are
presented. Section IV focuses on the network capacity and the
security aspect of coded caching is studied in section V. Cache
hit probability for both coded and uncoded caching approaches
is studied in section VI. In section VII, an efficient caching
update algorithm is proposed. Simulation results are provided
in section VIII. The paper is concluded in section IX.
II. RELATED WORK
Many researchers have investigated the problem of caching
in recent years. The fundamental limits of caching over a
shared link is studied in [22]. The authors in [22] suggested to
2Notice that the notion of proactive (or reactive) routing that we study is
the extreme case when complete (or no) network knowledge is available.
ar
X
iv
:1
70
9.
00
13
2v
1 
 [
cs
.I
T
] 
 1
 S
ep
 2
01
7
2
store uncoded contents or uncoded segments of the contents
in the caches during cache placement phase. During content
delivery phase, they proposed to broadcast coded files to the
users which resulted in significant multicasting gain. Such
a gain is achievable by taking advantage of content overlap
at various caches in the network, created by a central co-
ordinating server. This work was later extended in [23] to
scenarios with decentralized uncoded cache placement and
there are many other related works that followed the same set
of assumptions. While references [22], [23] study the problem
of caching in broadcast channels, we study the problem of
caching in wireless ad hoc networks using multihop commu-
nications.
The authors in [9] studied the problem of caching in multi-
hop networks. They assumed that during the cache placement
phase, uncoded contents are stored in the caches independently
in a decentralized fashion. They studied the throughput capac-
ity of wireless ad hoc networks. In this paper, we introduce
decentralized coded caching for wireless ad hoc networks and
compare our results with uncoded caching results in [9].
In decentralized uncoded caching scheme that we have
considered in this paper, we assumed that different contents
are selected uniformly at random and placed in the caches
during the cache placement phase. We can therefore model
the uncoded caching strategy as a coupon collector problem
with group drawings as studied in [27] and [10]. Similar
to the classical coupon collector problem, it is proved in
[10] that uniform selection of cached contents results in the
minimum possible value for the average number of required
hops. Hence, in this paper we study the case of uniform cache
placement which is the best possible scenario in terms of
network capacity.
Our proposed decentralized coded caching scheme utilizes
random uniform LT codes [20], [21], [26] to encode the
contents and store them during cache placement phase.
In random binary uniform LT codes [21], a random code
of length m is chosen from Fm2 such that any of its elements
is either equal to zero or one. Such a random code can be
represented by a random vector of length m in Fm2 . Then
contents with indices corresponding to one in the random
vector are added together and the encoded files are cached
in the nodes.
Physical layer security has attracted many researchers in
recent years. A survey of recent progress in this field can
be found in [1], [25]. Security aspects of network coding is
studied in references like [2], [19], [28]. In this paper, we will
study the security of LT coding-based caching technique. We
specifically investigate the last hop communication security
which is the most vulnerable transmission link. We prove that
for a certain regime of caching sizes in the network, asymptotic
perfect secrecy is achievable for the last hop3. Further, a secure
caching update algorithm is proposed.
Our proposed decentralized caching scheme can be used
to create a distributed network coding based storage system.
The concept of network coding for distributed storage was
originally studied in [4], [6] where files are divided into
3Security investigation for other hops remains as future work.
c1s(n)
sg(n)
c2c1s(n)
anchor
node
requesting
nodes
Fig. 1: Each local group with side length sg(n) contains many
square-lets of side length c1s(n). Each square-let has one
randomly selected anchor node.
packets and nodes need to collect all the packets to be able to
reconstruct their desired contents. In our proposed distributed
caching scheme, the requesting node needs to decode only
one content. The authors in [4], [6] study the repair problem
which is the problem of recovering data when some nodes
fail. Further, while they address the repair problem using MDS
codes, our proposed coded caching technique is based on LT
codes [20]. This paper focuses on the scaling capacity and
security of a network with decentralized coded caching which
is not studied in [4], [6].
LT coding based storage is studied in references like [3],
[29]. Reference [3] investigates the repair problem of LT codes
in cloud services and [29] proposes new types of LT codes for
storage systems. Use of fountain codes and Raptor codes [26]
has also been studied in [5], [17]. None of these references
have studied capacity, cache hit probabilities, cache update
algorithms and security of LT code based storage in wireless
ad hoc networks.
III. PRELIMINARIES
A. Network Model
We consider a dense wireless ad hoc network in which n
nodes are uniformly distributed over a square of unit area
as depicted in Figure 1. These nodes use multihop commu-
nications to request one of m contents from a set labeled
as F = {F1, F2, . . . , Fm}. The requested content is denoted
by Fr and the minimum number of nodes to decode Fr by
Nr. The minimum number of nodes to decode any requested
content is denoted by N . We also assume that each node
can cache M files of equal size each containing Q bits. In
practice, the contents are divided into equal-sized chunks and
the chunks are cached. Such an assumption is common in
many references including [13], [22], [23].
The unit square area in Figure 1 is divided into many
square-lets each with a side length of c1s(n) where s(n) =
3
?
log(n)/n. It is shown [18] that each square-let contains
?(log(n)) nodes with probability 1. To avoid multiple access
interference, a Protocol Model [30] is considered for success-
ful communication between nodes. A Time Division Multiple
Access (TDMA) scheme is assumed for the transmission
between the square-lets. With the assumption of Protocol
Model, if each square-let has a side length of c1s(n) for a
constant c1, then the square-lets with a distance of c2 = 2+?c1
square-lets apart can transmit simultaneously without signifi-
cant interference [18] for a constant value ?.
For our proactive routing analysis, we assume that one of
the nodes in each square-let is randomly chosen which is
called anchor node. This node collects all the information
in the square-let and combines them and relays the coded
information to the next hop toward the requesting node. It is
known that a minimum transmission range of ?
(?
log(n)
n
)
ensures network connectivity [11] in such a dense network.
For the case of uncoded caching with proactive routing, [9]
proposes a solution in which groups of neighboring square-
lets will cooperate together to form a local group. It is proved
[9] that for a square local group with side length sg(n) =
?
(?
m
nM
)
, any requested content is available in at least one
node in the local group. A routing protocol [18] within the
local group connects the source to destination through a series
of horizontal and vertical square-lets. The paper assumes that
all the nodes inside a local group have a global knowledge of
cached contents within each local group. Such an assumption
results in significant overhead which requires allocating part of
network resources to the exchange of this information. Further,
exchange of this information poses significant security threat
and allows an eavesdropper to find out which contents are
cached in the local group.
In this paper, we propose a decentralized coded caching
approach based on random vectors. In this technique, the
contents are randomly and independently combined and stored
in caches. When a node requests a content, a unique linear
combination of coded files can reconstruct the requested
content. Therefore, each node first combines its encoded files
and then transmits it to the anchor node (yellow circles in
Figure 1). The anchor node also adds some information from
its cache and forwards the newly updated file to the next
anchor node closer to the requesting node as shown in the
lower left local group in Figure 1. This process continues until
the requesting node receives all the required coded files for
decoding as shown in Figure 2. For reactive routing approach,
a random direction in the network is selected. Using the cached
information in this random direction, the desired content can
be obtained as shown in the upper left corner of Figure 1.
Interestingly, we prove selecting a random direction is optimal
in terms of number of hops traversed to retrieve the content.
In both cases, perfect communication secrecy is achievable.
B. Decentralized Coded Cache Placement
In our proposed coded cache placement approach, a ran-
domly encoded file rij is created and placed in the j
th cache
N1 N2 N4N0 N3 N5
N6 N7
N8
N9N10
Fig. 2: When a node N0 requests a file, it starts gathering the
coded files from all the nodes in its local group to construct
the requested content.
location of node i. This randomly encoded file is a bit-wise
summation of random contents from F . In other words,
rij =
m?
l=1
ai,jl Fl = v
i
jF, (1)
where F = [F1 F2 . . . Fm]T represents the contents vector
and vij = [a
i,j
1 a
i,j
2 . . . a
i,j
m ]
T ? Fm2 is a random row
vector with each element equal to 0 or 1 and the summation
is carried over Galois Field GF(2). This process is repeated
independently for all cache locations of all nodes4. Notice
that based on this construction, each vector vij is uniformly
selected from the set of all vectors in Fm2 . Notice that this
specific choice of fountain codes is known as Random Linear
Fountain (RLF) codes [21] or Random Uniform LT codes [26].
C. Content Reconstruction
In order to decode any of the contents, nodes need to find
m linearly independent vectors vij to span the m-dimensional
space. For each requested content Fr, a unique combination of
these encoded files will generate Fr. In both routing scenarios,
the computation of appropriate gains for the combination
of coded files is carried by the requesting node and this
information is relayed to the neighboring nodes.
As depicted in Figure 2, node Ni in the routing path
can contribute up to M linearly independent row vectors
vi1,v
i
2, . . . ,v
i
M to span the entire space. Node Ni applies gain
bij ? {0, 1} to its jth cached file rij and then adds (in binary
field)
?M
j=1 b
i
jr
i
j to the file it has received from previous hop
and passes the newly constructed file to the next hop toward
requesting node N0. After a total of Nr transmissions, the
requesting node receives (
?Nr
i=1
?M
j=1 b
i
jv
i
j)F. It will then
applies decoding coefficients to its own cached files and adds it
to the received file to reconstruct the desired content. Note that
each relay node adds some encoded files to the received file
and relays it forward. The coefficients bij ? {0, 1} are selected
such that the linear combination of encoded files produce the
desired requested content.
D. Prior Results
The coded caching was originally introduced in [12], [15]
for cellular networks. The following lemma was proved in
[12], [15].
4In practice, each node chooses M linearly independent random vectors
during cache placement phase. However, to simplify the analysis, we drop the
independence assumption for different cache locations of a node. Therefore,
analytical capacity results found in this paper are pessimistic.
4
Lemma 1. Let vector vij ? Fm2 have equiprobable elements.
The average number of vectors vij to span the m-dimensional
space equals to
Euniform = m+
m?
i=1
1
2i ? 1
= m+ c3, (2)
where c3 asymptotically approaches the Erdo?s–Borwein con-
stant (? 1.6067).
Lemma 1 shows that the average number of cached files to
reconstruct any content is equal to m+ c3 which is very close
to m for large values of m. This shows that random uniform
vectors perform close to optimal in terms of minimizing the
number of cache locations to retrieve contents. Based on
Lemma 1, we have the following corollary.
Corollary 1. If random uniform vectors are used to create
encoded files and then these files are independently cached
in node caches, then on average E[N ] = (m + c3)/M =
?(m/M) nodes are required to decode any requested content.
Theorem 1. In the proposed coded caching scheme, selecting
a random direction is asymptotically optimal in terms of
minimizing the number of hops required to retrieve all the
contents.
Proof. In the proposed coded caching scheme, random vectors
in Fm2 are used for encoding the contents. Lemma 1 shows
that on average m + c3 random vectors are needed to span
the m-dimensional space of Fm2 . Therefore, with the proposed
decentralized coded caching scheme, on average E[N ] =
d(m + c3)/Me nodes are required to decode any requested
content regardless of which routing direction is chosen for
content retrieval.
On the other hand, to be able to retrieve all the contents, at
least m cache locations are necessary. This means that at least
dm/Me nodes are required for content retrieval in any caching
scheme. Since m + c3 is very close to m for large values of
m, then ?(d(m + c3)/Me) = ?(dm/Me) = ?(m/M), this
proves that selecting any random direction is asymptotically
optimal in terms of the minimum required number of hops for
content retrieval.
Notice that Theorem 1 is intuitively valid since we have
used completely random vectors and this means that all of the
contents are equally distributed in all directions.
IV. CAPACITY
This section is dedicated to computation of network
throughput capacity of decentralized coded and uncoded
caching schemes for proactive and reactive routing techniques.
First, we define the precise notions of achievable throughput
and network throughput capacity as follows.
Definition 1. A network throughput of ?(n) contents per
second for each node is achievable if there is a scheme
for scheduling transmissions in the network, such that every
content request by each node can be served by a rate of ?(n)
contents per second.
Whether a particular network throughput is achievable de-
pends on the specific cache placement and node locations in
the network. Since the location of the nodes and the cache
placement in nodes is random, we will define the network
capacity as the maximum asymptotic network throughput
achievable with probability 1.
Definition 2. We say that the throughput capacity of the
network is lower bounded by ?(g(n)) contents per second
if a deterministic constant c5 > 0 exists such that
lim
n??
P[?(n) = c5g(n) is achievable ] = 1. (3)
We say thet the network throughput capacity is upper bounded
by O(g(n)) contents per second if a deterministic constant
c6 < +? exists such that
lim inf
n??
P[?(n) = c6g(n) is achievable ] < 1. (4)
We say that the network throughput capacity is of order
?(g(n)) contents per second if it is lower bounded by ?(g(n))
and upper bounded by O(g(n)).
In this paper, we study the throughput capacity after the
cache placement phase and during the content delivery phase.
In the following, we will describe the necessary size of the
local group to decode all the contents in proactive routing
approach.
Remark 1. Corollary 1 suggests that for decentralized coded
caching on average ?(m/M) nodes are needed to decode any
desired content. Since any local group in proactive routing on
average has ?(nsg(n)2) nodes, then the average local group
side length of sg(n) = ?
(?
m
nM
)
will be enough to decode
all the contents. Notice that similar local group side length is
found in [9] for the case of uncoded caching.
A. Capacity of proactive routing approach
In this section we assume that any node in each local group
is completely aware of all the files cached in its local group.
Nodes in local groups are cooperating with each other to
transfer a requested content. In uncoded caching scenario it
has been proved [9] that if M ? m < nM , a capacity of
?
(?
M/m
)
is achievable. Our proposed decentralized coded
caching approach achieves a capacity of ? (M/(m log(n)))
while providing perfect secrecy as will be proved subsequently.
Theorem 2. In decentralized coded caching with a proactive
routing scheme the following network throughput capacity is
achievable
?(n) = ?
(
M
m log(n)
)
. (5)
Proof. Corollary 1 shows that on average E[N ] = ?(m/M)
nodes are required to reconstruct all the contents in decentral-
ized coded caching. Remark 1 shows that each local group of
side length ?
(?
m
nM
)
contains this many nodes. As shown
in Figure 1, all these nodes cooperate to transmit the content
to the requesting node. Since there are ?(log(n)) nodes in
each square-let, the total number of transmissions for one
5
request in a local group is equal to ?
(
log(n)
(
sg(n)
s(n)
)2)
.
Therefore, the total number of file transmissions to satisfy
all content requests in each local group has the order of
?
(
log(n)
(
sg(n)
s(n)
)2
m
M
)
. On the other hand, in each local
group we can have ?
(
sg(n)
s(n)
)2
simultaneous transmissions.
This implies that a network throughput of
?(n) = ?
???
(
sg(n)
s(n)
)2
log(n)
(
sg(n)
s(n)
)2
m
M
??? = ?( M
m log(n)
)
(6)
is achievable.
B. Capacity of reactive routing approach
Reactive routing usually requires less overhead but incurs
higher delays in content delivery. However, one of the advan-
tages of our proposed coded caching is that we can select any
random direction and decode the desired content with the same
optimum number of nodes. Such a scenario is depicted in the
upper left corner of Figure 1.
For simplicity of our capacity analysis, we assume that all
contents are of equal size with each having Q bits. Assume
that ?(n) is the maximum achievable network throughput. This
implies that with a probability close to one, the network can
deliver n?(n) contents per second. Therefore, with a proba-
bility close to one, network nodes can transmit n?(n)E[N ]Q
bits per second. There are exactly 1(c2c1s(n))2 square-lets at
any time slot available for transmission. Hence, the total
number of bits that the network is capable of delivering is
equal to W(c2c1s(n))2 where W is the total available bandwidth.
Therefore,
?(n) =
W
nE[N ]Q(c2c1s(n))2
= ?
(
1
E[N ] log n
)
, (7)
where W and Q are the total available bandwidth and total
number of bits for each content respectively. This suggests
that to find the maximum achievable network throughput, it
is enough to find the average number of transmission hops
needed to deliver the contents.
Theorem 3. In decentralized coded caching with reactive
routing, the network capacity is
?(n) = ?
(
M
m log(n)
)
. (8)
Proof. Using Lemma 1, on average E[N ] = ?( mM ) nodes
(or equivalently hops) are required to decode a content in
decentralized coded caching. This along with equation (7)
proves the theorem.
In decentralized uncoded caching strategy, nodes cache
contents with uniform distribution. Lemma 2 computes the
average number of hops to retrieve a content.
Lemma 2. If a content is requested independently and uni-
formly at random from a set of m contents, then the average
number of requests to have at least one copy of each content
is equal to E[l] = m
?m
i=1
1
i = mHm = ?(m log(m)).
Proof. This is the well-known coupon collector problem [7].
Lemma 3. If each node stores M different files uniformly
at random during cache placement phase, then the average
number of nodes required so that each file is cached in at
least one node is between
mHm
d(m,M)
and 1 +
mHm
d(m,M)
where
d(m,M) =
M?1?
j=0
m
m? j
. (9)
Proof. This problem is an extension of the coupon collector
problem in Lemma 2 as the files in each node’s cache are
different. To find the average number of nodes to have one
copy of each file in at least one node, we start from a
classic coupon collector problem. Assume that files are chosen
uniformly at random and as soon as M different files are
found, they are placed in a node’s cache. Then the same
process is started over for the next node and after finding M
distinct files, the files are placed in its cache. Assume that this
process is repeated until one copy of each file is cached in at
least one node. This is a geometric distribution problem, then
on average d(m,M) files are required to fill up one node’s
cache. Based on Lemma 2, we will have a copy of each file in
at least one node’s cache after an average mHm file requests.
Hence, the average number of nodes required to have one
copy of each file in at least one node is between
mHm
d(m,M)
and 1 +
mHm
d(m,M)
.
Theorem 4. If m >> M , the capacity of the network using
decentralized uncoded caching is equal to
? = ?
(
M
m log(m) log(n)
)
. (10)
Proof. Lemma 3 shows that in case of uncoded caching the
average number of nodes needed to satisfy all requests is upper
and lower bounded as
mHm
d(m,M)
? E[N ] ? 1 + mHm
d(m,M)
. (11)
Therefore, for large values of m, the average number of nodes
for decoding scales as
E[N ] = ?
(
mHm
d(m,M)
)
. (12)
To find a bound for d(m,M), notice that the series in the right
hand side of equation (9) has M terms and the maximum term
m
m?M+1 corresponds to the case when j = M ? 1 and the
minimum term 1 corresponds to the case when j = 0. A lower
bound and an upper bound on d(m,M) can be found by using
the minimum and maximum terms respectively. Therefore,
M ? d(m,M) ? Mm
m?M + 1
. (13)
6
When m >> M , then the lower and upper bounds of equation
(13) converge to the same value of M .
E[N ] = ?
(
m log(m)
M
)
(14)
Combining (14) and (7) proves the theorem.
Remark 2. Theorems 3 and 4 show that decentralized coded
caching strategy can improve the network capacity by a factor
of log(m) in reactive routing.
Figure 3 compares the capacity of coded caching with
uncoded caching for both proactive and reactive routing al-
gorithms. To plot this figure, we assumed that the number of
contents m, grows polynomially with the number of nodes n.
Coded caching provides perfect secrecy as will be discussed
later while it performs better (worse) than uncoded caching
for reactive (proactive) routing algorithm.
10 2 10 3 10 4 10 5 10 6
n
10 -6
10 -5
10 -4
10 -3
10 -2
10 -1
10 0
C
a
p
a
c
it
y
Theoretical comparison of capacity
uncoded caching, proactive routing
uncoded caching, reactive routing
coded caching (reactive/proactive)
Fig. 3: Capacity for coded and uncoded caching using proac-
tive and reactive routing algorithms.
V. SECURITY
This section evaluates the security of coded caching strategy.
Note that uncoded caching allows an adversary with a noise-
less wiretap channel to perfectly receive the transmitted files.
We prove that such an eavesdropper will not be able to reduce
its equivocation about the transmitted files in coded caching
approach when there is a large number of files. Therefore,
asymptotic perfect secrecy can be achieved. This problem was
originally studied by Shannon [24].
Our secrecy proof is applicable to both proactive and reac-
tive routing schemes. As described earlier, each node combines
its encoded files as xi =
?M
j=1 b
i
jr
i
j =
?M
j=1 b
i
jv
i
jF and adds
it to the previously received file and forwards it to the next
hop. Therefore, the aggregate received file by the requesting
node N0 is Sr =
?Nr
i=1 x
i =
?Nr
i=1
?M
j=1 b
i
jr
i
j . We assume
that the encoding vectors vij of the neighboring nodes are
transmitted to the requesting node N0 through a secure low
bandwidth channel. When enough number of such vectors are
gathered, N0 computes the decoding coefficients bij in order
to generate the desired file Fr. Then, it sends back the bij
coefficients through the low bandwidth secure channel to its
neighboring nodes. The secure channel is used only to transmit
the encoding and decoding information. Transmitting the large
encoded files through secure channel would be undesirable due
to low bandwidth constraint. However, the encoding vectors
vij and the decoding gains b
i
j have much smaller sizes for
transmission through secure channel.
If content Fr is used in the encoding of at least one of the
coded cached files in N0 (i.e. a0,jr = 1 for some 1 ? j ?M ),
then the requesting node N0 can generate the file
x0r =
M?
j=1
b0jr
0
j =
M?
j=1
b0jv
0
jF = Fr +
M?
j=1
b
?0
j v
0
jF (15)
from its own encoded cached files. Note that vreq =?M
j=1 b
?0
j v
0
j is a coding vector in m-dimensional space. Node
N0 only needs to receive Sr = vreqF and add Sr to x0r in
GF(2) to retrieve Fr. The requesting node N0 uses the secure
channel to collect enough number of encoding vectors in order
to span vreq. Then the requesting nodeN0 finds the appropriate
decoding coefficients bij to span vreq and sends these decoding
coefficients back to the neighboring nodes through the secure
channel. The neighboring nodes collaboratively create the right
decoding file Sr and transmit it to N0.
The second possibility which is less likely to happen for
large values of M is that none of the encoded files in N0
contains Fr (i.e. a0,jr = 0 for all 1 ? j ?M ). In that case, N0
generates a unique combination of its encoded files as x0r =?M
j=1 b
0
jv
0
jF. In order to decode Fr, node N0 needs to receive
Sr = Fr + x
0
r . Hence, it uses the secure channel to collect
enough number of encoding vectors vij to be able to construct
Sr. After solving the linear equation in GF(2), it sends the
decoding gains back to the neighboring nodes such that they
can collaboratively create the encoded file Sr = Fr+x0r which
allows N0 to retrieve Fr.
We claim asymptotic perfect secrecy for this approach is
achievable as long as for each requested file Fr, the requesting
node generates a different encoded combination x0r which acts
similar to key and hence, the transmitted signal is in fact an
encrypted version of the message Fr. The intended receiver
is indeed capable of decrypting the message by adding its
secret key x0r to it. Notice that for each requested file Fr, a
different key x0r is generated using the encoded cached files
in the requesting nodes. No other eavesdropper will be able to
decode the message as they do not have the secret key x0r . The
main advantage of the legitimate receiver is the information
stored in its cache which allows it to create a unique key x0r
for each requested file Fr. This is similar to Shannon cipher
problem [24].
In [24], Shannon introduced the Shannon cipher system in
which an encoding function e : M × K ? C is mapping
a message M ? M and a key K ? K to a codeword C ?
C. In our problem, for each requested content by a user, the
legitimate receiver uses a unique key K to recover the message
M. Even when a different user requests the same file, it uses
a different key because each user caches different encoded
files. The unique key for each user depends on the coded files
that the node is storing and the coded files from neighboring
nodes used for decoding the requested file. Shannon proved
that if a coding scheme for Shannon’s cipher system achieves
7
perfect secrecy, then H(K) ? H(M) where H(.) denotes the
entropy. He proved that at least one secret key bit should be
used for each message bit to achieve perfect secrecy. If the
sizes of messages, keys and codewords are the same, there
are necessary and sufficient conditions [1] to obtain perfect
secrecy presented in the following theorem.
Theorem 5. If |M| = |K| = |C|, a coding scheme achieves
perfect secrecy if and only if
• For each pair (M,C) ? (M × C), there exists a unique
key K ? K such that C = e(M,K).
• The key K is uniformly distributed in K.
Proof. The proof can be found in section 3.1 of [1].
We will use Theorem 5 to prove that our approach can
achieve asymptotic perfect secrecy. In either of the cases, the
requesting node N0 receives a codeword5 Sr = Fr +x0r from
the last node adjacent to N0. Node N0 uses XOR operation to
decode Fr from Sr using it’s secret key x0r . Therefore, we have
a Shannon cipher system in which M = Fr,K = x0r,C = Sr
and e denotes the XOR operation. To use this theorem, first
we prove that for large enough values of m, the key x0r is
uniformly distributed.
Lemma 4. The asymptotic distribution of bits of coded files
in caches tend to uniform.
Proof. We assume that all files have Q bits and they may
have a distribution different from uniform. We will prove that
each coded cache file will be uniformly distributed for large
values of m. Let us denote the kth bit of file Fl by fkl where
1 ? k ? Q and 1 ? l ? m. Assume that Pr(fkl = 1) = pkl =
1?Pr(fkl = 0). Further, we assume that the bits of files (fkl )
are independent. The kth bit of the coded file in the jth cache
location of node i can be represented as
rki,j =
m?
l=1
ai,jl f
k
l , (16)
where ai,jl is a binary value with uniform distribution and
independent of all other bits. Using regular summation (not
over GF(2)) and denoting hi,j,kl , a
i,j
l f
k
l , we define H
i,j,k ,?m
l=1 h
i,j,k
l . Therefore, Pr[r
k
i,j = 0] = Pr[H
i,j,k 2? 0].
Therefore, the kth bit of the coded file is equal to 0 if an even
number of terms in Hi,j,k is equal to 1. The probability distri-
bution of Hi,j,k can be computed using probability generating
functions. Since hi,j,kl is a Bernoulli random variable with
probability 12p
k
l , its probability generating function is equal to
Gi,j,kl (z) = (1?
1
2
pkl ) +
1
2
pkl z. (17)
Since ai,jl and f
k
l are independent random variables, h
i,j,k
l
will become independent random variables. Therefore, the
probability generating function of Hi,j,k denoted by Gi,j,kH (z)
is the product of all probability generating functions.
Gi,j,kH (z) =
m?
l=1
(
(1? 1
2
pkl ) +
1
2
pkl z
)
. (18)
5This is true for both scenarios because all the operations are in GF(2).
Denoting the probability distribution of Hi,j,k as h(.), the
probability of Hi,j,k being even is
Pr[Hi,j,k
2? 0] =
bm2 c?
u=0
h(2u) =
bm2 c?
u=0
h(2u)z2u
????
z=1
=
1
2
[
m?
u=0
h(u)zu +
m?
u=0
h(u)(?z)u
]
z=1
=
1
2
Gi,j,kH (1) +
1
2
Gi,j,kH (?1) =
1
2
m?
l=1
(
(1? 1
2
pkl ) +
1
2
pkl
)
+
1
2
m?
l=1
(
(1? 1
2
pkl )?
1
2
pkl
)
=
1
2
(
1 +
m?
l=1
(
1? pkl
))
Therefore,
lim
m??
Pr[rki,j = 0] = lim
m??
1
2
(
1 +
m?
l=1
(
1? pkl
))
=
1
2
+
1
2
lim
m??
m?
l=1
(
1? pkl
)
=
1
2
+
1
2
lim
m??
(
1? inf{pkl }
)m
=
1
2
.
This proves the lemma.
This lemma paves the way to prove the following theorem.
Theorem 6. The proposed coded caching strategy provides
asymptotic perfect secrecy for the last hop if m is large and
m < 2M .
Proof. To formulate this as a Shannon cipher problem, we
assume that M = Fr, K = x0r , and C = Sr. The condition
m < 2M ensures that a unique key exists for each requested
message since at most 2M possible random keys can be built
from M cached files. The encoding function is XOR operation.
For any pair (m,C) ? (M,C), a unique key K ? K exists such
that C = m + K which guarantees that |M| = |K| = |C|.
Notice that the key K = x0r belongs to the set of all
possible bit strings with Q bits. Lemma 4 proves that each
coded cached content is uniformly distributed among all Q-
bit strings. Hence each key which is a unique summation
of cached encoded files is uniformly distributed among the
set of all Q-bit strings. In other words, regardless of the
distribution of the bits in files, x0r can be any bit string with
equal probability for large values of m. Therefore, conditions
of Theorem 5 are met and asymptotic perfect secrecy is
achieved.
Remark 3. In this paper, we only studied the security of last
hop communications in our approach and proved that even
in the most vulnerable (last) link, secure communications is
possible. A more general security study for all links remains
as future work. Also, the study of the security of this approach
against cooperative eavesdroppers remains as future work.
VI. CACHE HIT PROBABILITY
This section is dedicated to computation of cache hit prob-
ability when a node N0 can access u other nodes N1, . . . ,Nu
or equivalently, l = uM cache locations. We compute the
event that N0 can decode any desired file in the set F with
this information. First, let’s define the cache hit probability.
8
Definition 3. The cache hit probability for all contents is
defined as the probability that any content can be retrieved
using the cached information in nodes N1, . . . ,Nu.
We will first study uncoded cache hit probability.
A. Uncoded Caching
In uncoded caching, each node is randomly choosing M
different contents from the set of m contents. This can be
modeled as a coupon collector problem with group drawings
in which a coupon collector is collecting a number of different
coupons in each time and wants to find the probability that
after u group collections, all the contents are collected. The
result studied before [10], [27] and is summarized below.
Theorem 7. Assume that a coupon collector collects m
different coupons. Each time a bundle of M different coupons
are drawn uniformly at random. If u bundles are collected,
then the probability that all the coupons are collected is equal
to
Pall collected =
m?M?
j=0
(?1)j
(
m
j
)((m?j
M
)(
m
M
) )u (19)
Proof. The proof can be found in [27] (a special case of
Theorem 1) and also in page 164 of [10].
Result of Theorem 7 is the cache hit probability for collect-
ing all contents when uncoded caching is used.
B. Coded caching
In coded caching, we compute the probability that there
exists m linearly independent vectors within l = uM random
encoding vectors. If m > l = uM , this probability is clearly
zero. Therefore, without loss of generality, we compute this
probability when l = uM ? m. This problem has been studied
in literature [16] and the results are summarized below.
Theorem 8. Let l ? m ? 1 and s be positive integers and
r = l ?m. If A = [aij ] is an l ×m matrix whose elements
are independent binary uniform random variables and ?m(l)
is the rank of matrix A in GF(2), then if m?? we have
P[?m(l) = m? s]? 2?s(s+r)
??
i=s+1
(
1? 1
2i
)
×
r+s?
j=1
(
1? 1
2j
)?1
, (20)
where the last product equals 1 for s+ r = 0.
Proof. This is Theorem 3.2.1 in page 126 of [16].
Corollary 2. Let l ? m and A = [aij ] be an l ×m matrix
whose elements are independent binary uniform random vari-
ables and ?m(l) be the rank of matrix A in GF(2). If m??,
then
P[?m(l) = m]?
??
i=l?m+1
(
1? 1
2i
)
. (21)
Equation (21) is the cache hit probability for coded caching
approach.
Remark 4. The cache hit probability for coded caching very
quickly approaches 1 if l is slightly larger than m. In fact,
there is a very sharp transitioning of the probability from 0
to 1 in coded caching around the point l = m. However, in
uncoded caching, l should be much larger than m in order for
the cache hit probability tends to 1 (see Figure 5).
Remark 5. This result demonstrates that coded caching
scheme utilizes the cache space efficiently and avoids over-
caching unlike uncoded caching approach.
VII. CACHE UPDATE ALGORITHM
In this section, a caching update algorithm is described.
Let’s assume a new content Fnew should replace another
content Fk based on some replacement policy such as Least
Recently Used (LRU) or Least Frequently Used (LFU) policy.
The network controller uses a bit scrambling technique to
create a file F
?
new with uniform bit distribution from Fnew. Such
bit scrambling techniques are widely used in communication
systems to give the transmitted data useful engineering prop-
erties [8]. Notice that the bit scrambling technique makes F
?
new
equivalent of temporary secret key with uniform distribution.
The network controller then generates Fk + F
?
new and broad-
casts this file to the network nodes. When node Ni receives
Fk + F
?
new, it will add Fk + F
?
new to all of its cached encoded
files rij which contain Fk, i.e., all r
i
j’s for which a
i,j
k = 1. In
other words, if in the jth location of node i we have
rij = Fk +
m?
l=1
l 6=k
ai,jl Fl, (22)
then Fk+F
?
new will be added to r
i
j . This replaces Fk with F
?
new
in all encoded files that contains Fk. If some cached encoded
files does not contain Fk, then no action is required for those
encoded files. Nodes can then decode F
?
new using the same
decoding gains as for Fk without any additional overhead.
When F
?
new is decoded, then a de-scrambling algorithm can be
used to recover Fnew from F
?
new. A pseudocode representation
of our caching update protocol is shown in Algorithm 1.
Algorithm 1 Cache Update Algorithm
1: procedure CACHE UPDATE
2: Find the content Fk that should be replaced.
3: Scramble Fnew to get F
?
new with uniform bits.
4: Encode the new content F
?
new with Fk as F
?
new ? Fk.
5: Broadcast F
?
new ? Fk to all the nodes.
6: for the jth cache location of node i do
7: if Fk is used in encoding rij (i.e. a
i,j
k = 1) then
8: Update the jth cache location of node i with
F
?
new ? Fk ? rij .
9: end if
10: end for
11: end procedure
9
10 20 30 40 50 60 70 80 90 100
Cache size (M)
0
5
10
15
20
25
30
35
40
45
50
A
v
e
ra
g
e
 n
u
m
b
e
r 
o
f 
h
o
p
s
Average number of hops versus cache size
Coded Caching (North Direction)
Coded Caching (South Direction)
Coded Caching (West Direction)
Coded Caching (East Direction)
Uncoded Caching
Fig. 4: Average required number of hops (nodes) for coded
and uncoded caching schemes to retrieve a content.
Notice that during the caching update phase none of the
contents is transmitted and any eavesdropper would only re-
ceive encoded version of the files. Therefore, with this caching
update technique, the contents can be updated securely.
VIII. SIMULATION
This section verifies the analytical results derived earlier
via simulations. Figure 4 compares the average number of
hops required to decode the contents in decentralized coded
and uncoded caching schemes. We consider a wireless ad hoc
network with n = 1000 nodes and m = 100 contents. The
simulation results clearly demonstrate that decentralized coded
caching outperforms uncoded case particularly when the cache
size is small which is the most likely operating regime. For
instance, with decentralized coded content caching, a cache
of size 25 only requires less than 5 hops while decentralized
uncoded content caching needs around 20 hops for successful
content retreival. This makes coded content caching much
more practical compared to uncoded content caching. Note that
capacity is inversely proportional to the average hop counts.
As can be seen from Figure 4, for small cache sizes, coded
caching significantly reduces the number of hops required to
decode the contents. This property is important for nodes with
small storage capability since large number of hops can impose
excessive delay and low quality of service.
Figure 4 proves another important result that content re-
trieval can be optimally done in any random direction. In this
plot, we have used random directions of east, west, south and
north for content retrieval using coded caching and shown
that the average number of hops in any of these random
directions is the same. The four plots corresponding to these
four directions is so close that it is hard to distinguish them.
Figure 5 shows the simulation results for different values of
M when m = 100. The cache hit probability is plotted as a
function of the number of cached contents l and for different
cache sizes M . However, for each fixed value of l, the number
of nodes µ = lM will be different depending on M . For
instance, at l = 400, M and µ are 25 and 16 respectively.
The simulation results are validating the theoretical results in
Theorem 7 and Corollary 2. As can be seen from this figure,
the cache hit probability for coded caching is much higher
100 150 200 250 300 350 400 450 500
Number of cached contents
-0.2
0
0.2
0.4
0.6
0.8
1
P
ro
b
a
b
ili
ty
 o
f 
d
e
c
o
d
in
g
 a
n
y
 d
e
s
ir
e
d
 c
o
n
te
n
t
Probability of decoding versus the number of cached contents
Coded caching, m = 100, all M, (Simulation)
Coded caching, m = 100, all M, (Theory)
Uncoded caching, m = 100, (Simulation)
Uncoded caching, m = 100, (Theory)
M=25
M=20
M=10
M=5
Fig. 5: Cache hit probability for any desired content when
m = 100.
than that of uncoded caching. Also, it is clear from this plot
that the cache hit probability of coded caching approaches
1 rapidly when l starts to be greater than m. For uncoded
caching, specially when m is large, the receiver should access
a much larger number of cached contents in order for the
cache hit probability to approach 1. Therefore, in networks
with a large number of contents our coded caching approach
will quickly achieve a cache hit probability close to one with a
much smaller number of cache locations. This is a significant
benefit of our technique in reducing overcaching.
IX. CONCLUSIONS
This paper introduces a novel decentralized coded caching
strategy in wireless ad hoc networks. The capacity of this
approach is compared with that of uncoded caching for
proactive and reactive routing protocols. While with proactive
routing protocol, uncoded caching outperforms coded caching,
coded caching performs better with reactive routing protocol.
Interestingly, it was shown that by choosing any random
direction, close to optimum number of hops can be obtained
to retrieve any content in coded caching.
It has been shown that coded caching approach provides
asymptotic perfect secrecy during file transmission. We have
also studied the cache hit problem and shown that the cache hit
probability for any desired content will be significantly higher
in the proposed technique compared to uncoded caching.
This technique reduces the problem of overcaching in the
networks. An efficient and secure cache update algorithm is
also proposed and the results are validated with simulations.
The paper considered a static network, however our results
can be extended to mobile or vehicular networks when the
transmission time is much smaller than the network dynamics.
Further, the size of the file chunks can be adjusted based on
the network dynamics to adapt to the rate of change in the
network evolution.
This paper considered random linear fountain codes to
achieve asymptotic perfect secrecy and better cache hit prob-
ability and capacity results. Other fountain coding choices for
cache placement may reduce the decoding complexity while
reducing the capacity and cache hit probability. Selection of
10
appropriate fountain code depends on many factors such as
decoding complexity, delay and capacity requirements.
REFERENCES
[1] Matthieu Bloch and Joao Barros. Physical-layer security: from informa-
tion theory to security engineering. Cambridge University Press, 2011.
[2] Ning Cai and Raymond W Yeung. Secure network coding. In
Proceedings of IEEE International Symposium on Information Theory,
ISIT, page 323. IEEE, 2002.
[3] Ning Cao, Shucheng Yu, Zhenyu Yang, Wenjing Lou, and Y. Thomas
Hou. LT codes-based secure and reliable cloud storage service. In
Proceedings of the IEEE INFOCOM 2012, Orlando, FL, USA, March
25-30, pages 693–701, 2012.
[4] Alexandros G. Dimakis, Brighten Godfrey, Yunnan Wu, Martin J.
Wainwright, and Kannan Ramchandran. Network coding for distributed
storage systems. IEEE Trans. Information Theory, 56(9):4539–4551,
2010.
[5] Alexandros G. Dimakis, Vinod M. Prabhakaran, and Kannan Ramchan-
dran. Distributed fountain codes for networked storage. In Proceedings
of International Conference on Acoustics Speech and Signal Processing,
ICASSP 2006, Toulouse, France, May 14-19, pages 1149–1152, 2006.
[6] Alexandros G. Dimakis, Kannan Ramchandran, Yunnan Wu, and
Changho Suh. A survey on network codes for distributed storage.
Proceedings of the IEEE, 99(3):476–489, 2011.
[7] Paul Erdo?s. On a classical problem of probability theory. 1961.
[8] Yan Hui. Method and apparatus for data scrambling/descrambling,
May 29 2003. US Patent App. 09/997,639.
[9] Sang-Woon Jeon, Song-Nam Hong, Mingyue Ji, and Giuseppe Caire.
Caching in wireless multihop device-to-device networks. In Proceedings
of International Conference on Communications, ICC 2015, London,
United Kingdom, June 8-12, pages 6732–6737, 2015.
[10] Norman Lloyd Johnson and Samuel Kotz. Urn models and their
application; an approach to modern discrete probability theory. 1977.
[11] Mohsen Karimzadeh Kiskani, Bita Azimdoost, and Hamid R. Sadjad-
pour. Effect of social groups on the capacity of wireless networks. IEEE
Trans. Wireless Communications, 15(1):3–13, 2016.
[12] Mohsen Karimzadeh Kiskani and Hamid R. Sadjadpour. Capacity of
cellular networks with femtocache. In Proceedings of the IEEE Confer-
ence on Computer Communications Workshops, INFOCOM Workshops,
San Francisco, USA, April 10 - 15, 2016.
[13] Mohsen Karimzadeh Kiskani and Hamid R. Sadjadpour. Multihop
caching-aided coded multicasting for the next generation of cellular
networks. IEEE Trans. Vehicular Technology, 66(3):2576–2585, 2017.
[14] Mohsen Karimzadeh Kiskani and Hamid R. Sadjadpour. Secure coded
caching in wireless ad hoc networks. In Proceedings of the International
Conference on Computing, Networking and Communications, ICNC
2017, Silicon Valley, CA, USA, January 26-29, pages 387–391, 2017.
[15] Mohsen Karimzadeh Kiskani and Hamid R. Sadjadpour. Throughput
analysis of decentralized coded content caching in cellular networks.
IEEE Trans. Wireless Communications, 16(1):663–672, 2017.
[16] Valentin Fedorovich Kolchin. Random graphs. Number 53. Cambridge
University Press, 1999.
[17] Zhenning Kong, Salah A. Aly, and Emina Soljanin. Decentralized coding
algorithms for distributed storage in wireless sensor networks. IEEE
Journal on Selected Areas in Communications, 28(2):261–267, 2010.
[18] Sanjeev R. Kulkarni and Pramod Viswanath. A deterministic approach
to throughput scaling in wireless networks. IEEE Trans. Information
Theory, 50(6):1041–1049, 2004.
[19] Luisa Lima, Muriel Me?dard, and Joao Barros. Random linear network
coding: A free cipher? In Proceedings of the International Symposium
on Information Theory, ISIT 2007, pages 546–550. IEEE, 2007.
[20] Michael Luby. LT codes. In Proceedings of the 43rd Symposium on
Foundations of Computer Science, FOCS 2002, Vancouver, BC, Canada,
page 271, 16-19 November 2002.
[21] David JC MacKay. Fountain codes. IEE Proceedings-Communications,
152(6):1062–1068, 2005.
[22] Mohammad Ali Maddah-Ali and Urs Niesen. Fundamental limits of
caching. IEEE Trans. Information Theory, 60(5):2856–2867, 2014.
[23] Mohammad Ali Maddah-Ali and Urs Niesen. Decentralized coded
caching attains order-optimal memory-rate tradeoff. IEEE/ACM Trans.
Netw., 23(4):1029–1040, 2015.
[24] Claude E Shannon. Communication theory of secrecy systems. Bell
system technical journal, 28(4):656–715, 1949.
[25] Yi-Sheng Shiu, Shih Yu Chang, Hsiao-Chun Wu, Scott C.-H. Huang,
and Hsiao-Hwa Chen. Physical layer security in wireless networks: a
tutorial. IEEE Wireless Commun., 18(2):66–74, 2011.
[26] Amin Shokrollahi. Raptor codes. IEEE Trans. Information Theory,
52(6):2551–2567, 2006.
[27] Wolfgang Stadje. The collector’s problem with group drawings. Ad-
vances in Applied Probability, pages 866–882, 1990.
[28] Saeed Vahidian, Sonia A??ssa, and Sajad Hatamnia. Relay selection
for security-constrained cooperative communication in the presence of
eavesdropper’s overhearing and interference. IEEE Wireless Communi-
cations Letters, 4(6):577–580, 2015.
[29] Yongge Wang. LT codes for efficient and reliable distributed storage
systems revisited. arXiv preprint arXiv:1207.5542, 2012.
[30] Feng Xue and Panganamala R. Kumar. Scaling laws for ad hoc wireless
networks: An information theoretic approach. Foundations and Trends
in Networking, 1(2), 2006.
Mohsen Karimzadeh Kiskani received his B.S.
degree in Mechanical Engineering and M.S. degree
in Electrical Engineering from Sharif University of
Technology in 2008 and 2010, respectively. He is
currently a Ph.D. candidate in Electrical Engineer-
ing department at University of California, Santa
Cruz. His research interests include wireless com-
munications, information theory, and the application
of fountain codes, LT codes and Raptor codes in
wireless networks and storage systems. He is also
interested in complexity study of Constraint Satis-
faction Problems (CSP) in Computer Science. In June 2016 he obtained a
M.S. degree in Computer Science from University of California Santa Cruz.
Hamid Sadjadpour (S’94–M’95–SM’00) received
Ph.D. degree in Electrical Engineering from Uni-
versity of Southern California at Los Angeles, CA.
In 1995, he joined AT&T Research Laboratory in
Florham Park, NJ as a Technical Staff Member and
later as a Principal Member of Technical Staff. In
2001, he joined University of California at Santa
Cruz, CA, where he is currently a Professor. His
research interests are in the general areas of wireless
communications and networks.
